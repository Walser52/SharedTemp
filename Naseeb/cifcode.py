# -*- coding: utf-8 -*-
"""cifcode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v9PHUtHWf8KKZ-CBNp5WMxYoJT2USA1j
"""

# Import necessary libraries
import matplotlib.pyplot as plt

# Path to the uploaded file in Google Colab
file_path = '/content/cleaned_energy_iterations.txt'  # Adjust path if necessary

# Initialize lists to store iteration numbers and energies
iterations = []
energies = []

# Read the data from the file
with open(file_path) as file:
    for line in file:
        data = line.split()  # Split by space
        iterations.append(int(data[0]))  # Add iteration number to list
        energies.append(float(data[1]))  # Add energy to list

# Plot the data
plt.figure(figsize=(8, 6))
plt.plot(iterations, energies, marker='o', linestyle='-', color='b', label='Total Energy')
plt.xlabel("SCF Iteration Number")
plt.ylabel("Total Energy (Ry)")
plt.title("Convergence of Total Energy")
plt.grid(True)
plt.legend()
plt.show()

import matplotlib.pyplot as plt

# Path to the uploaded file in Google Colab
file_path = '/content/cleaned_energy_iterations.txt'  # Adjust path if necessary

# Initialize lists to store iteration numbers and energies
iterations = []
energies = []

# Read the data from the file
with open(file_path) as file:
    for line in file:
        line = line.strip()  # Remove leading/trailing spaces

        # Skip lines that don't contain valid energy values
        if "=" not in line:  # Only process lines with "=" sign
            continue

        # Extract the part after "=" sign and clean up
        parts = line.split("=")
        if len(parts) > 1:
            energy = parts[1].strip()  # Get the energy part and remove extra spaces
            try:
                # Try converting the energy to float, if it's valid
                energies.append(float(energy))  # Append energy value
                # Calculate the iteration number (assumes that lines are in order)
                iterations.append(len(iterations) + 1)  # Iteration number is simply the count of previous energies
            except ValueError:
                continue  # Skip lines where conversion to float fails

# Plot the data
plt.figure(figsize=(8, 6))
plt.plot(iterations, energies, marker='o', linestyle='-', color='b', label='Total Energy')
plt.xlabel("SCF Iteration Number")
plt.ylabel("Total Energy (Ry)")
plt.title("Convergence of Total Energy")
plt.grid(True)
plt.legend()
plt.show()

import matplotlib.pyplot as plt

# Path to the uploaded file in Google Colab
file_path = '/content/cleaned_energy_iterations.txt'  # Adjust path if necessary

# Initialize lists to store iteration numbers and energies
iterations = []
energies = []

# Read the data from the file
with open(file_path) as file:
    for line in file:
        line = line.strip()  # Remove leading/trailing spaces

        # Skip lines that don't contain valid energy values
        if "=" not in line:  # Only process lines with "=" sign
            continue

        # Extract the part after "=" sign and clean up
        parts = line.split("=")
        if len(parts) > 1:
            energy = parts[1].strip()  # Get the energy part and remove extra spaces
            try:
                # Try converting the energy to float, if it's valid
                energies.append(float(energy))  # Append energy value
                # Calculate the iteration number (assumes that lines are in order)
                iterations.append(len(iterations) + 1)  # Iteration number is simply the count of previous energies

                # Debugging output to check the data being appended
                print(f"Iteration {len(iterations)}: Energy = {energy}")  # Print iteration and energy
            except ValueError:
                print(f"Skipping invalid line: {line}")  # Debug output for invalid lines
                continue  # Skip lines where conversion to float fails

# Debug output for final lists
print(f"Total Iterations: {len(iterations)}")
print(f"Total Energies: {len(energies)}")

# Check if we have any data before plotting
if len(iterations) == 0 or len(energies) == 0:
    print("Error: No valid data to plot!")
else:
    # Plot the data
    plt.figure(figsize=(8, 6))
    plt.plot(iterations, energies, marker='o', linestyle='-', color='b', label='Total Energy')
    plt.xlabel("SCF Iteration Number")
    plt.ylabel("Total Energy (Ry)")
    plt.title("Convergence of Total Energy")
    plt.grid(True)
    plt.legend()
    plt.show()

import matplotlib.pyplot as plt

# Path to the uploaded file in Google Colab
file_path = '/content/cleaned_energy_iterations.txt'  # Adjust path if necessary

# Initialize lists to store iteration numbers and energies
iterations = []
energies = []

# Read the data from the file
with open(file_path) as file:
    for line in file:
        line = line.strip()  # Remove leading/trailing spaces

        # Skip lines that don't contain valid energy values (e.g., lines like "10 =")
        if "=" not in line:
            continue

        # Split by "=" and check if there's valid energy data after it
        parts = line.split("=")
        if len(parts) > 1:
            energy = parts[1].strip()  # Get the energy part and remove extra spaces
            try:
                # Try converting the energy to float, if it's valid
                energy_value = float(energy)
                energies.append(energy_value)  # Append valid energy value
                iterations.append(len(iterations) + 1)  # Iteration number is the count of energies
            except ValueError:
                # Skip invalid lines that cannot be converted to a float
                continue

# Debug output for the final lists
print(f"Total Iterations: {len(iterations)}")
print(f"Total Energies: {len(energies)}")

# Check if we have any valid data to plot
if len(iterations) == 0 or len(energies) == 0:
    print("Error: No valid data to plot!")
else:
    # Plot the data
    plt.figure(figsize=(8, 6))
    plt.plot(iterations, energies, marker='o', linestyle='-', color='b', label='Total Energy')
    plt.xlabel("SCF Iteration Number")
    plt.ylabel("Total Energy (Ry)")
    plt.title("Convergence of Total Energy")
    plt.grid(True)
    plt.legend()
    plt.show()

import matplotlib.pyplot as plt

# Path to the uploaded file in Google Colab
file_path = '/content/cleaned_energy_iterations.txt'  # Adjust path if necessary

# Initialize lists to store iteration numbers and energies
iterations = []
energies = []

# Read the data from the file
with open(file_path) as file:
    for line in file:
        # Strip leading/trailing spaces
        line = line.strip()

        # Split the line by spaces
        data = line.split()

        # Make sure the line has two parts: iteration and energy
        if len(data) == 2:
            try:
                # Convert the second part (energy) to float
                iteration = int(data[0])
                energy = float(data[1])

                # Append the values to the lists
                iterations.append(iteration)
                energies.append(energy)
            except ValueError:
                # Skip lines where conversion fails (just in case)
                continue

# Debug output to see the total number of iterations and energies
print(f"Total Iterations: {len(iterations)}")
print(f"Total Energies: {len(energies)}")

# Check if there are valid data points
if len(iterations) == 0 or len(energies) == 0:
    print("Error: No valid data to plot!")
else:
    # Plot the data
    plt.figure(figsize=(8, 6))
    plt.plot(iterations, energies, marker='o', linestyle='-', color='b', label='Total Energy')
    plt.xlabel("SCF Iteration Number")
    plt.ylabel("Total Energy (Ry)")
    plt.title("Convergence of Total Energy")
    plt.grid(True)
    plt.legend()
    plt.show()

# Import the necessary packages and modules
import matplotlib.pyplot as plt
plt.style.use('../../ matplotlib/sci.mplstyle')
import numpy as np

# Fermi energy for your system (in eV), from SCF output
# the Fermi energy is     4.1750 ev
efermi = 4.1750

# Load data from LGPS.bands.gnu
data = np.loadtxt('LGPS.bands.gnu')
k = np.unique(data[:, 0])
bands = np.reshape(data[:, 1], (-1, len(k)))

# Define high-symmetry k-points index (based on your path)
# GAMMA - X - Y - GAMMA - Z - R_2 - GAMMA - T_2 - GAMMA - U_2 - GAMMA - V_2
sym_idx = [0, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220]
sym_labels = [r'$\Gamma$', 'X', 'Y', r'$\Gamma$', 'Z', 'R', r'$\Gamma$', 'T', r'$\Gamma$', 'U', r'$\Gamma$', 'V']

# Create figure object
plt.figure(figsize=(8, 6))

# Plot dotted line at Fermi level
plt.axhline(0, color='gray', linestyle=':')

# Plot vertical lines at high-symmetry points
for i in sym_idx:
    plt.axvline(k[i], color='gray', linestyle=':')

# Plot band structure (shifted by Fermi energy)
for band in bands:
    plt.plot(k, band - efermi, color='b')

# Set axis labels
plt.ylabel('Energy (eV)')
plt.xlabel('')

# Set limits
plt.xlim(k[0], k[-1])
plt.ylim(-10, 10)  # Adjust as needed

# Set x-ticks at symmetry points
plt.xticks([k[i] for i in sym_idx], sym_labels)

# Hide minor ticks
plt.tick_params(axis='x', which='minor', bottom=False, top=False)

# Save and show the figure
plt.savefig('LGPS_bandstructure.pdf')
plt.show()

# Import required libraries
import matplotlib.pyplot as plt
import numpy as np

# Optional: use a clean built-in style
plt.style.use('seaborn-v0_8')

# -----------------------------
# 1. Fermi Energy from SCF
# -----------------------------
# the Fermi energy is     4.1750 ev
efermi = 4.1750

# -----------------------------
# 2. Load band structure data
# -----------------------------
data = np.loadtxt('LGPS.bands.gnu')
k = np.unique(data[:, 0])  # Unique k-point positions
bands = np.reshape(data[:, 1], (-1, len(k)))  # Reshape bands

# -----------------------------
# 3. High-symmetry point setup
# -----------------------------
num_segments = 12  # You used 12 segments in K_POINTS
points_per_segment = len(k) // num_segments  # Auto-calculate

sym_idx = [i * points_per_segment for i in range(num_segments)]
sym_labels = [r'$\Gamma$', 'X', 'Y', r'$\Gamma$', 'Z', 'R', r'$\Gamma$', 'T', r'$\Gamma$', 'U', r'$\Gamma$', 'V']

# -----------------------------
# 4. Plotting
# -----------------------------
plt.figure(figsize=(8, 6))

# Plot horizontal line at Fermi level
plt.axhline(0, color='gray', linestyle=':')

# Plot vertical lines at high-symmetry k-points
for i in sym_idx:
    plt.axvline(k[i], color='gray', linestyle=':')

# Plot each band, shifted by Fermi energy
for band in bands:
    plt.plot(k, band - efermi, color='blue')

# Axis labels and limits
plt.ylabel('Energy (eV)')
plt.xlabel('')
plt.xlim(k[0], k[-1])
plt.ylim(-10, 10)  # Adjust depending on your material

# Symmetry point labels
plt.xticks([k[i] for i in sym_idx], sym_labels)

# Ticks formatting
plt.tick_params(axis='x', which='minor', bottom=False, top=False)

# Save and show the plot
plt.tight_layout()
plt.savefig('LGPS_bandstructure.pdf')
plt.show()

# Import required libraries
import matplotlib.pyplot as plt
import numpy as np

# -----------------------------
# 1. Fermi Energy from SCF
# -----------------------------
# the Fermi energy is     4.1750 eV
efermi = 4.1750

# -----------------------------
# 2. Load band structure data
# -----------------------------
data = np.loadtxt('LGPS.bands.gnu')
k = np.unique(data[:, 0])  # Unique k-point positions
bands = np.reshape(data[:, 1], (-1, len(k)))  # Reshape bands

# -----------------------------
# 3. High-symmetry point setup
# -----------------------------
num_segments = 12  # You used 12 segments in K_POINTS
points_per_segment = len(k) // num_segments  # Auto-calculate

sym_idx = [i * points_per_segment for i in range(num_segments)]
sym_labels = [r'$\Gamma$', 'X', 'Y', r'$\Gamma$', 'Z', 'R', r'$\Gamma$', 'T', r'$\Gamma$', 'U', r'$\Gamma$', 'V']

# -----------------------------
# 4. Plotting
# -----------------------------
plt.figure(figsize=(8, 6))

# Plot horizontal line at Fermi level
plt.axhline(0, color='gray', linestyle=':')

# Plot vertical lines at high-symmetry k-points
for i in sym_idx:
    plt.axvline(k[i], color='gray', linestyle=':')

# Plot each band, shifted by Fermi energy
for band in bands:
    plt.plot(k, band - efermi, color='blue')

# Axis labels and limits
plt.ylabel('Energy (eV)')
plt.xlabel('')
plt.xlim(k[0], k[-1])
plt.ylim(-10, 10)  # Adjust depending on your material

# Symmetry point labels
plt.xticks([k[i] for i in sym_idx], sym_labels)

# Ticks formatting
plt.tick_params(axis='x', which='minor', bottom=False, top=False)

# Save and show the plot
plt.tight_layout()
plt.savefig('LGPS_bandstructure.pdf')
plt.show()

import matplotlib.pyplot as plt

# Atoms vs Voltage data
atoms = [3,4,7,8,11,12,15,16,19,20,23]
voltage = [1.4,0.7,0.7,0.3,0.3,0.2,0.2,0.1,0.1,0.05,0.05]

# Plot
plt.figure(figsize=(8, 5))
plt.plot(atoms, voltage, marker='o', linestyle='-', color='blue', label='Voltage vs Atoms')

# Labels and title
plt.xlabel("Number of Atoms")
plt.ylabel("Voltage (V)")
plt.title("Voltage vs Atoms Behavior")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Data for HOP-Graphene
atoms_hop = [3,4,7,8,11,12,15,16,19,20,23]
voltage_hop = [1.4,0.7,0.7,0.3,0.3,0.2,0.2,0.1,0.1,0.05,0.05]

# Data for WS2-Graphene
atoms_ws2 = [1,2,3,4,5,6]
voltage_ws2 = [0.85,0.82,0.74,0.71,0.7,0.69]

# Plot
plt.figure(figsize=(8, 5))
plt.plot(atoms_hop, voltage_hop, 'o-', label='HOP-Graphene', color='blue')
plt.plot(atoms_ws2, voltage_ws2, 's--', label='WS₂–Graphene', color='green')

# Labels and formatting
plt.xlabel("Number of Atoms")
plt.ylabel("Voltage (V)")
plt.title("Voltage vs Number of Atoms for Two Anode Materials")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

!pip install pybamm --quiet

import matplotlib.pyplot as plt

# Data
ecutwfc = [35, 40, 45, 50, 55, 60, 65]
total_energy = [-5990.30054209, -5990.31595804,
                -5990.31971929, -5990.32485368, -5990.32632420,
                -5990.32642165, -5990.32732091]

# Convert to meV for relative comparison
e_min = min(total_energy)
energy_diff_meV = [(e - e_min) for e in total_energy]  # 1 Ry = 13.605 eV → if you want in eV use that

# Plot
plt.figure(figsize=(8, 5))
plt.plot(ecutwfc, energy_diff_meV, marker='o', linestyle='-', color='blue')
plt.xlabel('ecutwfc (Ry)')
plt.ylabel('Relative Total Energy (meV)')
plt.title('Convergence of Total Energy w.r.t. ecutwfc')
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Your data
k_grids = ['1×2×2', '1×5×5', '2×3×3', '2×4×4']
total_energies = [-5990.31570301, -5990.31616324, -5990.31595739, -5990.31595804]

# Plotting
plt.figure(figsize=(8, 5))
plt.plot(k_grids, total_energies, marker='o', linestyle='-', color='blue')
plt.xlabel('K-point Grid')
plt.ylabel('Total Energy (Ry)')
plt.title('K-point Convergence')
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

kpoints = ['1×2×2', '1×5×5', '2×3×3', '2×4×4']
energies = [-5990.3057, -5990.3164, -5990.3108, -5990.3108]  # Example values in Ry

plt.figure(figsize=(8, 5))
plt.plot(kpoints, energies, marker='o', color='blue')
plt.title('K-point Convergence')
plt.xlabel('K-point Grid')
plt.ylabel('Total Energy (Ry)')
plt.grid(True)
for i, e in enumerate(energies):
    plt.annotate(f"{e:.4f}", (kpoints[i], energies[i]), textcoords="offset points", xytext=(0,10), ha='center')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

kpoints = ['1×2×2', '1×5×5', '2×3×3', '2×4×4']
energies = [-5990.3057, -5990.3164, -5990.3108, -5990.3108]  # Example values in Ry
ref_energy = min(energies)
delta_E = [e - ref_energy for e in energies]  # ΔE in Ry

plt.figure(figsize=(8, 5))
plt.plot(kpoints, delta_E, marker='o', linestyle='-', color='green')
plt.title('K-point Convergence (ΔE relative to minimum)')
plt.xlabel('K-point Grid')
plt.ylabel('ΔE (Ry)')
plt.grid(True)
for i, de in enumerate(delta_E):
    plt.annotate(f"{de:.5f}", (kpoints[i], delta_E[i]), textcoords="offset points", xytext=(0,10), ha='center')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Sample data
k_labels = ['1×2×2', '1×5×5', '2×3×3', '2×4×4']
k_points = [1*2*2, 1*5*5, 2*3*3, 2*4*4]  # total k-points
energies = [-5990.31570301, -5990.31616324, -5990.31595739, -5990.31595804]  # in Ry

# Reference energy (lowest one)
ref_energy = min(energies)

# Plot
plt.figure(figsize=(8, 5))
plt.scatter(k_points, energies, color='royalblue', s=60)
plt.axhline(ref_energy, linestyle='--', color='gray', label=f'Ref: {ref_energy:.5f} Ry')

plt.title("Total Energy vs Number of K-points")
plt.xlabel("Number of k-points")
plt.ylabel("Total Energy (Ry)")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

from ase.io import read
import spglib
import numpy as np
import os
from ase.spacegroup import Spacegroup
from ase.io.cif import write_cif

# Path to your scf output file
vc-relax_path = "path"

# Step 1: Read the structure
atoms = read(scf_path, format='espresso-out')

# Step 2: Get space group information using spglib
cell = (atoms.get_cell(), atoms.get_scaled_positions(), atoms.get_atomic_numbers())
spacegroup_symbol = spglib.get_spacegroup(cell, symprec=1e-5)
dataset = spglib.get_symmetry_dataset(cell, symprec=1e-5)

# Extract space group number from the symbol
spacegroup_number = int(spacegroup_symbol.split('(')[1].split(')')[0])

print("\nSpace group information:")
print(f"International symbol: {spacegroup_symbol}")
print(f"Space group number: {spacegroup_number}")
print(f"Hall symbol: {dataset.hall}")
print(f"Point group: {dataset.pointgroup}")

# Step 3: Create structure with only symmetry-inequivalent atoms
equivalent_atoms = dataset.equivalent_atoms
unique_indices = np.unique(equivalent_atoms)
symmetrized_atoms = atoms[unique_indices].copy()

# Step 4: Set the output path for the CIF file
output_path = os.path.join(os.path.dirname(scf_path), "symmetrized_structure.cif")

# Step 5: Write the CIF file - using binary mode
with open(output_path, 'wb') as fd:  # Note 'wb' for binary writing
    write_cif(fd, symmetrized_atoms)

print(f"\nCreated symmetrized CIF file with {len(unique_indices)} symmetry-inequivalent atoms")
print(f"Saved as: {output_path}")

# Step 6: Print symmetry-inequivalent atoms information
print(f"\nSymmetry inequivalent atoms ({len(unique_indices)}):")
for i, atom_idx in enumerate(unique_indices):
    atom = atoms[atom_idx]
    print(f"\nAtom {i+1}:")
    print(f"  Element: {atom.symbol}")
    print(f"  Fractional coordinates: {dataset.std_positions[atom_idx]}")
    print(f"  Wyckoff letter: {dataset.wyckoffs[atom_idx]}")
    print(f"  Site symmetry: {dataset.site_symmetry_symbols[atom_idx]}")



import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import make_interp_spline

# Image index (reaction coordinate)
images = np.array([1, 2, 3, 4, 5, 6, 7, 8])

# Total energies from your output (in eV)
energies = np.array([
    -13792.7456845,
    -13793.3526224,
    -13793.1372471,
    -13792.7330675,
    -13792.6506205,
    -13793.2309597,
    -13793.1359496,
    -13792.3745997
])

# Shift energies so the minimum is 0 eV (common in NEB plots)
energies -= energies.min()

# Interpolate to smooth the curve
x_smooth = np.linspace(images.min(), images.max(), 300)
spl = make_interp_spline(images, energies, k=3)
y_smooth = spl(x_smooth)

# Plot
plt.figure(figsize=(8, 5))
plt.plot(x_smooth, y_smooth, label="Smoothed NEB Path", color='blue')
plt.scatter(images, energies, color='red', label="NEB Images")
plt.xlabel("Reaction Coordinate (Image Index)")
plt.ylabel("Relative Energy (eV)")
plt.title("HER NEB Energy Profile – Ni-doped WS₂")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import FancyArrow

# Image indices (reaction coordinate)
images = np.array([1, 2, 3, 4, 5, 6, 7, 8])
energies = np.array([
    -13792.7456845,
    -13793.3526224,
    -13793.1372471,
    -13792.7330675,
    -13792.6506205,
    -13793.2309597,
    -13793.1359496,
    -13792.3745997
])

# Shift so minimum = 0
energies -= energies.min()

# Plot setup
fig, ax = plt.subplots(figsize=(6, 6))

# Plot energy profile with green dots and lines
ax.plot(images, energies, '-o', color='green', markerfacecolor='green', markeredgecolor='black')

# Label axes
ax.set_xlabel("Reaction coordinate", fontsize=14)
ax.set_ylabel("Energy, E (eV)", fontsize=14)
ax.tick_params(labelsize=12)
ax.set_xlim(0.5, 8.5)
ax.set_ylim(0, max(energies) + 0.1)

# Add activation barrier arrow
max_idx = np.argmax(energies)
max_x = images[max_idx]
max_y = energies[max_idx]

ax.annotate("ΔE = {:.2f} eV".format(max_y),
            xy=(max_x, max_y/2), xytext=(max_x+0.5, max_y/2),
            fontsize=12, ha='center',
            arrowprops=dict(arrowstyle='<->', color='black', lw=1.5))

# Optional: Add label (a)
ax.text(0.2, 1.02 * max(energies), "(a)", fontsize=14)

# Square plot, tight layout
ax.set_aspect('auto')
plt.tight_layout()

# Save high-res
plt.savefig("neb_profile_her_ws2.png", dpi=600)

plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Energies (in eV) from your latest NEB iteration, image 1 to 5
energies = np.array([
    -13789.4966427,
    -13790.6562455,
    -13790.8275388,
    -13792.0250423,
    -13788.6293648
])

# Normalize energies relative to image 1 (initial state)
energies_rel = energies - energies[0]

# Image indices (1 to 5)
images = np.arange(1, 6)

# Plotting
plt.figure(figsize=(8,5))
plt.plot(images, energies_rel, marker='o', linestyle='-', color='blue')
plt.xlabel("Image Index")
plt.ylabel("Relative Energy (eV)")
plt.title("Minimum Energy Path (NEB)")
plt.grid(True)
plt.xticks(images)
plt.axhline(0, color='gray', linestyle='--')
plt.text(images[np.argmax(energies_rel)], max(energies_rel)+0.05,
         f"Activation Energy ≈ {max(energies_rel):.3f} eV", color='red')

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Energy values extracted from iteration 20 of nebb.out
image_indices = [1, 2, 3, 4, 5]
energies = [-13789.4966427, -13792.6091625, -13792.1975212, -13792.9685934, -13788.6293648]

# Shift to relative energy (eV above minimum)
min_energy = min(energies)
relative_energies = [e - min_energy for e in energies]

# Plot
plt.figure(figsize=(8, 5))
plt.plot(image_indices, relative_energies, marker='o', linestyle='-', color='blue')
plt.title('NEB Energy Profile (After 20 Steps)')
plt.xlabel('Image Index')
plt.ylabel('Relative Energy (eV)')
plt.xticks(image_indices)
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Raw total energies from iteration 69
image_indices = [1, 2, 3, 4, 5, 6, 7, 8]
energies = [
    -13789.4966427,
    -13792.3380121,
    -13793.3327258,
    -13793.0322658,
    -13792.9347881,
    -13793.2440132,
    -13792.8296756,
    -13788.6293648
]

# Shift energies to relative scale (minimum energy = 0)
min_energy = min(energies)
relative_energies = [e - min_energy for e in energies]

# Plot
plt.figure(figsize=(8, 5))
plt.plot(image_indices, relative_energies, marker='o', linestyle='-', color='darkgreen')
plt.title('NEB Energy Profile (Iteration 69)', fontsize=14)
plt.xlabel('Image Index', fontsize=12)
plt.ylabel('Relative Energy (eV)', fontsize=12)
plt.grid(True)
plt.xticks(image_indices)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import argrelextrema

# Extract the energy data from your NEB output (replace with your actual data)
# Format: [image_number, energy(eV), error(eV/A), frozen(T/F)]
final_iteration_data = [
    [1, -13789.4966427, 3.119489, True],
    [2, -13792.2147953, 0.025142, False],
    [3, -13793.3026158, 0.052353, False],
    [4, -13793.0139850, 0.086081, False],
    [5, -13792.9520683, 0.081932, False],
    [6, -13793.2410291, 0.021075, False],
    [7, -13792.7774364, 0.043844, False],
    [8, -13788.6293648, 22.160487, True]
]

# Convert to numpy array
data = np.array(final_iteration_data)
image_numbers = data[:, 0]
energies = data[:, 1]
forces = data[:, 2]

# Normalize energies relative to first image
normalized_energies = energies - energies[0]

# Find saddle point (maximum energy along the path)
saddle_point_idx = np.argmax(normalized_energies)
saddle_point_energy = normalized_energies[saddle_point_idx]

# Create the plot
plt.figure(figsize=(10, 6))

# Plot energy profile
plt.plot(image_numbers, normalized_energies, 'bo-', linewidth=2, markersize=8, label='Energy')

# Highlight saddle point
plt.plot(image_numbers[saddle_point_idx], normalized_energies[saddle_point_idx],
         'ro', markersize=10, label=f'Saddle Point (Image {int(image_numbers[saddle_point_idx])}: {saddle_point_energy:.3f} eV)')

# Plot forces (scaled for visualization)
scaled_forces = forces / np.max(forces) * np.max(normalized_energies) * 0.5
plt.plot(image_numbers, scaled_forces, 'g--', linewidth=1, label='Force magnitude (scaled)')

# Add labels and title
plt.xlabel('Image Number', fontsize=12)
plt.ylabel('Relative Energy (eV)', fontsize=12)
plt.title('NEB Energy Profile and Saddle Point Identification', fontsize=14)
plt.xticks(image_numbers)
plt.grid(True, alpha=0.3)
plt.legend(fontsize=10)

# Annotate the saddle point
plt.annotate(f'TS: {saddle_point_energy:.3f} eV',
             xy=(image_numbers[saddle_point_idx], normalized_energies[saddle_point_idx]),
             xytext=(10, 10), textcoords='offset points',
             bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.5),
             arrowprops=dict(arrowstyle='->'))

plt.tight_layout()
plt.show()

# Print key information
print(f"Saddle point found at Image {int(image_numbers[saddle_point_idx])}")
print(f"Activation energy (forward): {saddle_point_energy:.3f} eV")
print(f"Activation energy (reverse): {saddle_point_energy - normalized_energies[-1]:.3f} eV")
print(f"Maximum force at saddle point: {forces[saddle_point_idx]:.3f} eV/Å")

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

# Data from your NEB output (replace with your actual values)
image_numbers = np.array([1, 2, 3, 4, 5, 6, 7, 8])
energies = np.array([-13789.4966427, -13792.2147953, -13793.3026158,
                    -13793.0139850, -13792.9520683, -13793.2410291,
                    -13792.7774364, -13788.6293648])
forces = np.array([3.119489, 0.025142, 0.052353, 0.086081,
                  0.081932, 0.021075, 0.043844, 22.160487])

# Normalize energies relative to first image
normalized_energies = (energies - energies[0]) * 1000  # Convert to meV for better scale

# Create figure with two subplots
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8),
                              gridspec_kw={'height_ratios': [3, 1]},
                              sharex=True)

# Energy profile plot
ax1.plot(image_numbers, normalized_energies, 'bo-',
        linewidth=2, markersize=8, label='Energy (relative)')

# Highlight saddle point
saddle_idx = np.argmax(normalized_energies)
ax1.plot(image_numbers[saddle_idx], normalized_energies[saddle_idx],
        'ro', markersize=10,
        label=f'Transition State (Image {image_numbers[saddle_idx]}: {normalized_energies[saddle_idx]:.1f} meV)')

ax1.set_ylabel('Relative Energy (meV)', fontsize=12)
ax1.legend(loc='upper right', fontsize=10)
ax1.grid(True, alpha=0.3)
ax1.yaxis.set_major_locator(MaxNLocator(integer=True))

# Force magnitude plot
ax2.bar(image_numbers, forces, color='orange', alpha=0.6, label='Force magnitude')
ax2.set_xlabel('Image Number', fontsize=12)
ax2.set_ylabel('Force (eV/Å)', fontsize=12)
ax2.axhline(y=0.1, color='red', linestyle='--', linewidth=1, label='Convergence threshold')
ax2.legend(loc='upper right', fontsize=10)
ax2.grid(True, alpha=0.3)
ax2.set_yscale('log')  # Log scale for better force visualization

# Highlight problematic images
for i, force in enumerate(forces):
    if force > 0.1:  # Highlight images with high forces
        ax2.annotate(f'High force: {force:.1f}',
                    xy=(image_numbers[i], force),
                    xytext=(0, 10), textcoords='offset points',
                    ha='center', color='red')

plt.suptitle('NEB Analysis: Energy Profile and Forces', fontsize=14, y=1.02)
plt.tight_layout()
plt.show()

# Print key metrics
print("\n=== NEB Analysis Results ===")
print(f"Transition state at Image {image_numbers[saddle_idx]}")
print(f"Activation energy: {normalized_energies[saddle_idx]:.1f} meV ({normalized_energies[saddle_idx]/1000:.3f} eV)")
print(f"End-to-end energy difference: {normalized_energies[-1]:.1f} meV")
print("\nForce analysis:")
for img, force in zip(image_numbers, forces):
    status = "⚠️ High" if force > 0.1 else "✓ OK"
    print(f"Image {img}: {force:.3f} eV/Å {status}")

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import AutoMinorLocator
plt.style.use('default')  # Reset to default style first
plt.style.use('seaborn-poster')  # Professional scientific style

# ========== DATA FROM YOUR NEB CALCULATION ==========
# Replace these with your actual values
image_numbers = np.array([1, 2, 3, 4, 5, 6, 7, 8])  # Reaction coordinate
energies = np.array([0.00, -2.72, -3.81, -3.52, -3.46, -3.74, -3.28, 0.87])  # Relative energies in eV
forces = np.array([3.12, 0.03, 0.05, 0.09, 0.08, 0.02, 0.04, 22.16])  # Forces in eV/Å

# ========== CREATE PUBLICATION-QUALITY PLOT ==========
fig, ax = plt.subplots(figsize=(8,6), dpi=300)

# Main energy profile plot
line = ax.plot(image_numbers, energies, 'o-', color='#1f77b4',
               markersize=8, linewidth=2.5, markeredgecolor='k',
               markeredgewidth=0.8, label='Reaction Pathway')

# Highlight transition state
ts_idx = np.argmax(energies)
ax.plot(image_numbers[ts_idx], energies[ts_idx], 's',
        color='#d62728', markersize=10, markeredgecolor='k',
        markeredgewidth=0.8, label=f'TS ({energies[ts_idx]:.2f} eV)')

# Formatting for journal quality
ax.set_xlabel('Reaction Coordinate', fontsize=14, labelpad=10)
ax.set_ylabel('Gibbs Free Energy (eV)', fontsize=14, labelpad=10)
ax.set_title('HER Reaction Pathway: ΔG = {:.2f} eV'.format(energies[ts_idx]),
             fontsize=16, pad=15)

# Add energy reference lines
ax.axhline(0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)
ax.axhline(energies[-1], color='#2ca02c', linestyle=':',
           linewidth=1.5, alpha=0.7, label='Final State')

# Professional formatting
ax.xaxis.set_minor_locator(AutoMinorLocator())
ax.yaxis.set_minor_locator(AutoMinorLocator())
ax.tick_params(axis='both', which='major', labelsize=12, length=6, width=1)
ax.tick_params(axis='both', which='minor', length=3, width=1)
ax.grid(True, which='both', linestyle=':', alpha=0.3)

# Add activation energy annotation
ax.annotate('', xy=(image_numbers[ts_idx], y=0),
            xytext=(image_numbers[ts_idx], y=energies[ts_idx]),
            arrowprops=dict(arrowstyle='<->', color='k', lw=1.5))
ax.text(image_numbers[ts_idx]+0.2, energies[ts_idx]/2,
        r'$\Delta G^\ddagger$ = {:.2f} eV'.format(energies[ts_idx]),
        fontsize=12, ha='left', va='center')

# Add HER-specific annotations
ax.text(0.02, 0.95, 'Volmer Step', transform=ax.transAxes,
        fontsize=10, bbox=dict(facecolor='white', alpha=0.8))
ax.text(0.6, 0.8, 'Heyrovsky/Tafel Step', transform=ax.transAxes,
        fontsize=10, bbox=dict(facecolor='white', alpha=0.8))

# Legend and final adjustments
ax.legend(fontsize=12, framealpha=1)
fig.tight_layout()

# Save publication-ready figure
plt.savefig('HER_NEB_pathway.png', dpi=300, bbox_inches='tight', transparent=False)
plt.show()

# ========== CATALYSIS-SPECIFIC ANALYSIS ==========
print("\n=== HER Catalysis Performance Analysis ===")
print(f"1. Thermodynamic overpotential: {abs(energies[-1]):.2f} eV")
print(f"2. Activation barrier (ΔG‡): {energies[ts_idx]:.2f} eV")
print(f"3. Potential-determining step: Image {image_numbers[ts_idx]}")

if energies[ts_idx] > 0.8:
    print("\n⚠️ Warning: High activation barrier (>0.8 eV) suggests poor HER activity")
if abs(energies[-1]) > 0.2:
    print("⚠️ Warning: Significant thermodynamic overpotential (>0.2 eV)")

images = [1, 2, 3, 4, 5, 6, 7, 8]
energies = [-13789.496, -13789.707, ..., -13792.374]  # Replace with your data
plt.plot(images, energies, 'o-')
plt.xlabel('Image'); plt.ylabel('Energy (eV)')
plt.title(f'NEB Barrier: Forward={9.41:.2f} eV, Reverse={12.29:.2f} eV')
plt.show()

import matplotlib.pyplot as plt  # Add this import at the top

# Your data
images = [1, 2, 3, 4, 5, 6, 7, 8]
energies = [-13789.4966427, -13789.7072563, -13789.3205006,
            -13785.5205059, -13780.0848596, -13784.1474528,
            -13790.8277065, -13792.3745997]  # From your NEB output

# Plotting
plt.plot(images, energies, 'o-', markersize=8, linewidth=2)
plt.xlabel('Image Number', fontsize=12)
plt.ylabel('Energy (eV)', fontsize=12)
plt.title(f'NEB Barrier: Forward={9.41:.2f} eV, Reverse={12.29:.2f} eV', fontsize=14)
plt.grid(alpha=0.3)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Data from iteration 2 (most recent complete iteration)
images = np.array([1, 2, 3, 4, 5, 6, 7, 8])
energies = np.array([-13789.4966427, -13789.7933974, -13789.5470135,
                    -13788.6639689, -13790.1183090, -13790.5277908,
                    -13791.4354021, -13792.3745997])

# Calculate relative energies (eV) from first image
relative_energies = (energies - energies[0])

# Create the plot
plt.figure(figsize=(10, 6))
plt.plot(images, relative_energies, 'o-', markersize=8, linewidth=2,
         color='#1f77b4', markerfacecolor='red')

# Highlight key points
plt.scatter(4, relative_energies[3], s=200, color='orange',
            label=f'TS (0.83 eV)', zorder=5)  # Transition State (Image 4)
plt.axhline(0, color='black', linestyle='--', alpha=0.5)  # Reactant level

# Annotations
plt.annotate('Reactant', xy=(1, 0), xytext=(1.5, 0.2),
             arrowprops=dict(arrowstyle="->"))
plt.annotate('Product', xy=(8, relative_energies[-1]),
             xytext=(6.5, relative_energies[-1]+0.2),
             arrowprops=dict(arrowstyle="->"))

# Formatting
plt.xticks(images)
plt.xlabel('Image Number', fontsize=12, fontweight='bold')
plt.ylabel('Relative Energy (eV)', fontsize=12, fontweight='bold')
plt.title('HER on Ni-WS₂: NEB Progress (Iteration 2)\n'
          f'Forward Barrier = 0.83 eV | Reverse Barrier = 3.71 eV',
          fontsize=14, pad=20)
plt.grid(alpha=0.3)
plt.legend()

# Add energy difference arrows
plt.annotate('', xy=(1, 0), xytext=(8, relative_energies[-1]),
             arrowprops=dict(arrowstyle="<->", color='green', lw=2))
plt.text(4.5, -1.5, 'ΔE = -2.87 eV', ha='center', color='green',
         fontsize=12, bbox=dict(facecolor='white', alpha=0.8))

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Iteration 2 Data
images = [1, 2, 3, 4, 5, 6, 7, 8]
energies = [-13789.4966427, -13789.7933974, -13789.5470135,
           -13788.6639689, -13790.1183090, -13790.5277908,
           -13791.4354021, -13792.3745997]

# Convert to relative energies (eV)
relative_energies = [e - energies[0] for e in energies]

# Plot
plt.figure(figsize=(8,5))
plt.plot(images, relative_energies, 'ro-', markersize=8, linewidth=2)

# Highlight Transition State (Image 4)
plt.scatter(4, relative_energies[3], s=150, color='gold',
            label=f'TS (0.83 eV)', zorder=5)

# Formatting
plt.xticks(images)
plt.xlabel('Image Number', fontweight='bold')
plt.ylabel('Relative Energy (eV)', fontweight='bold')
plt.title('HER on Ni-WS₂: NEB Iteration 2\nForward Barrier = 0.83 eV', pad=15)
plt.grid(alpha=0.2)
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

images = [1, 2, 3, 4, 5, 6, 7, 8]
energies = [-13789.4966427, -13791.9757479, -13793.2024088, -13792.8690891,
            -13792.7066133, -13793.1435817, -13793.2179239, -13792.3745997]
relative_energies = [e - energies[0] for e in energies]

plt.figure(figsize=(8,5))
plt.plot(images, relative_energies, 'o-', label='NEB Path')
plt.scatter(1, 0, color='green', s=100, label='Reactant (Image 1)')
plt.scatter(8, relative_energies[-1], color='blue', s=100, label='Product (Image 8)')
plt.scatter(7, relative_energies[6], color='red', s=100, label='Saddle Point')
plt.xlabel('Image Number')
plt.ylabel('Energy Relative to Reactant (eV)')
plt.title('Converged NEB Energy Profile')
plt.grid(True)
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Energies in eV from NEB output (as given)
energies = np.array([
    -13789.4966427,  # Image 1
    -13791.9838542,  # Image 2
    -13793.2146659,  # Image 3
    -13792.8761915,  # Image 4
    -13792.7175571,  # Image 5
    -13793.1400426,  # Image 6
    -13793.2189093,  # Image 7
    -13792.3745997   # Image 8
])

# Shift to relative energies (eV)
relative_energies = energies - energies.min()

# Plot
plt.figure(figsize=(8, 5))
plt.plot(range(1, 9), relative_energies, 'o-', lw=2, markersize=8, color='royalblue')
plt.xlabel("Image Number", fontsize=12)
plt.ylabel("Relative Energy (eV)", fontsize=12)
plt.title("NEB Minimum Energy Path", fontsize=14)
plt.grid(True)
plt.xticks(range(1, 9))
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Final iteration NEB image energies
energies = np.array([
    -13789.4966427,  # Image 1 (initial)
    -13792.0129216,  # Image 2
    -13793.2330195,  # Image 3 (likely saddle point)
    -13792.9012997,  # Image 4
    -13792.7351113,  # Image 5
    -13793.1299149,  # Image 6
    -13793.2216694,  # Image 7
    -13792.3745997   # Image 8 (final)
])

# Relative energy (eV)
relative_energies = energies - energies.min()

# Plot
plt.figure(figsize=(8, 5))
plt.plot(range(1, 9), relative_energies, 'o-', lw=2, markersize=8, color='mediumblue')
plt.xlabel("Image Index", fontsize=12)
plt.ylabel("Relative Energy (eV)", fontsize=12)
plt.title("NEB Minimum Energy Path (Converged)", fontsize=14)
plt.xticks(range(1, 9))
plt.grid(True)
plt.tight_layout()
plt.show()

# Install matplotlib if needed
!pip install matplotlib --quiet

# Importing necessary libraries
import matplotlib.pyplot as plt

# === NEB Data ===
image_indices = [1, 2, 3, 4, 5, 6, 7, 8]
energies = [
    -13792.7456845,
    -13792.5217606,
    -13792.1132627,
    -13791.4037841,
    -13791.2838055,  # climbing image
    -13791.9327170,
    -13792.2781093,
    -13792.3745997
]
climbing_image_index = 5  # Image 5 is the climbing image

# Normalize energies to the minimum value
min_energy = min(energies)
relative_energies = [e - min_energy for e in energies]

# Plotting
plt.figure(figsize=(8, 5))
plt.plot(image_indices, relative_energies, marker='o', linestyle='-', color='darkorange', label="NEB Energy Profile")
plt.axvline(x=climbing_image_index, color='red', linestyle='--', label='Climbing Image')
plt.title("NEB Energy Profile (eV)")
plt.xlabel("Image Index")
plt.ylabel("Relative Energy (eV)")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Install matplotlib (if not already installed)
!pip install matplotlib --quiet

import matplotlib.pyplot as plt

# === NEB Iteration 7 Data ===
image_indices = [1, 2, 3, 4, 5, 6, 7, 8]
energies = [
    -13792.7456845,
    -13792.7543740,
    -13792.4127763,
    -13791.7191830,
    -13791.6765526,  # Climbing image
    -13792.3045943,
    -13792.5356591,
    -13792.3745997
]
climbing_image_index = 5  # Based on your output

# Normalize energies relative to the minimum
min_energy = min(energies)
relative_energies = [e - min_energy for e in energies]

# Plotting
plt.figure(figsize=(8, 5))
plt.plot(image_indices, relative_energies, marker='o', linestyle='-', color='mediumblue', label="NEB Path (iter 7)")
plt.axvline(x=climbing_image_index, color='red', linestyle='--', label="Climbing Image")
plt.title("NEB Energy Profile (Iteration 7)")
plt.xlabel("Image Index")
plt.ylabel("Relative Energy (eV)")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Install required package (if needed)
!pip install matplotlib scipy --quiet

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import make_interp_spline

# === Your NEB final image data (iteration 30) ===
image_indices = np.array([1, 2, 3, 4, 5, 6, 7, 8])
energies = np.array([
    -13792.7456845,
    -13793.3526224,
    -13793.1372471,
    -13792.7330675,
    -13792.6506205,
    -13793.2309597,
    -13793.1359496,
    -13792.3745997
])

# Normalize energies relative to the minimum (set min = 0 eV)
min_energy = np.min(energies)
rel_energies = energies - min_energy  # in eV

# Interpolate for smooth curve
x_new = np.linspace(image_indices.min(), image_indices.max(), 300)
spline = make_interp_spline(image_indices, rel_energies, k=3)
y_smooth = spline(x_new)

# Create the plot
plt.figure(figsize=(8, 5))
plt.plot(x_new, y_smooth, label='NEB Pathway', color='royalblue', linewidth=2)
plt.scatter(image_indices, rel_energies, color='black', zorder=5)

# Mark transition state
ts_index = np.argmax(rel_energies) + 1  # image index with highest energy
plt.axvline(x=ts_index, color='red', linestyle='--', label='Transition State')

# Plot decorations
plt.title('NEB Energy Profile for H on Ni-doped WS₂', fontsize=14)
plt.xlabel('Image Index (Reaction Coordinate)', fontsize=12)
plt.ylabel('Relative Energy (eV)', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.4)
plt.xticks(image_indices)
plt.legend()
plt.tight_layout()
plt.show()

# Install matplotlib (if needed in Colab)
!pip install matplotlib --quiet

import numpy as np
import matplotlib.pyplot as plt

# === Your NEB final iteration data (Iteration 30) ===
image_indices = np.array([1, 2, 3, 4, 5, 6, 7, 8])
energies = np.array([
    -13792.7456845,
    -13793.3526224,
    -13793.1372471,
    -13792.7330675,
    -13792.6506205,
    -13793.2309597,
    -13793.1359496,
    -13792.3745997
])

# Normalize energies to the minimum
min_energy = np.min(energies)
rel_energies = energies - min_energy  # relative to the most stable image

# Find the transition state (maximum energy point)
ts_index = np.argmax(rel_energies) + 1  # +1 for 1-based indexing like NEB output

# Plotting
plt.figure(figsize=(8, 5))
plt.plot(image_indices, rel_energies, marker='o', linestyle='-', color='royalblue', linewidth=2, label='NEB Path')
plt.axvline(x=ts_index, color='red', linestyle='--', label=f'Transition State (Image {ts_index})')

# Styling for publication
plt.title('NEB Energy Profile for H on Ni-doped WS₂', fontsize=14)
plt.xlabel('Image Index (Reaction Coordinate)', fontsize=12)
plt.ylabel('Relative Energy (eV)', fontsize=12)
plt.xticks(image_indices)
plt.grid(True, linestyle='--', alpha=0.3)
plt.legend()
plt.tight_layout()

# Optional: Save as high-quality image
# plt.savefig("neb_profile.png", dpi=600)
# plt.savefig("neb_profile.pdf")

plt.show()



import matplotlib.pyplot as plt

# Voltage values (same for all three temperatures)
voltage = [0, 0, 0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
           0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
           0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
           0.842105263, 0.894736842, 0.947368421, 1]

# Current at 260K
current_260K = [8.67191405e-14, 8.67191405e-14, 3.38059378e-06, 1.40949685e-05,
                5.04702463e-05, 0.000175844954, 0.000612655124, 0.00215743276,
                0.00774925487, 0.0287733314, 0.112703395, 0.472781785,
                1.99266622, 6.65733649, 15.2736091, 26.6886371, 39.8475849,
                54.1948029, 69.4467818, 85.4471044, 102.100342]

# Current at 300K
current_300K = [-8.28396217e-14, -8.28396217e-14, 0.000148116285, 0.000554052138,
                0.00175082122, 0.00537015093, 0.0165756447, 0.0524358052,
                0.172358453, 0.587566883, 1.94612565, 5.36388414,
                11.269495, 19.078815, 28.1436994, 38.0659191, 48.6226599,
                59.6855136, 71.1759666, 83.0427182, 95.2499017]

# Current at 460K (same values as 300K as per your data)
current_460K = current_300K.copy()

# Plotting
plt.figure(figsize=(10, 6))
plt.plot(voltage, current_260K, 'o-', label='260K')
plt.plot(voltage, current_300K, 's-', label='300K')
plt.plot(voltage, current_460K, '^-', label='460K')

# Labels and title
plt.xlabel('Voltage (V)', fontsize=12)
plt.ylabel('Current Density (A/cm²)', fontsize=12)
plt.title('I-V Characteristics at Different Temperatures', fontsize=14)
plt.grid(True)
plt.legend()
plt.yscale('log')  # Use logarithmic scale for better visibility
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage values (same for all temperatures)
voltage = [0, 0, 0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
           0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
           0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
           0.842105263, 0.894736842, 0.947368421, 1]

# Current at 260K
current_260K = [8.67191405e-14, 8.67191405e-14, 3.38059378e-06, 1.40949685e-05,
                5.04702463e-05, 0.000175844954, 0.000612655124, 0.00215743276,
                0.00774925487, 0.0287733314, 0.112703395, 0.472781785,
                1.99266622, 6.65733649, 15.2736091, 26.6886371, 39.8475849,
                54.1948029, 69.4467818, 85.4471044, 102.100342]

# Current at 300K (corrected)
current_300K = [-8.28396217e-14, -8.28396217e-14, 0.000148116285, 0.000554052138,
                0.00175082122, 0.00537015093, 0.0165756447, 0.0524358052,
                0.172358453, 0.587566883, 1.94612565, 5.36388414,
                11.269495, 19.078815, 28.1436994, 38.0659191, 48.6226599,
                59.6855136, 71.1759666, 83.0427182, 95.2499017]

# Current at 460K (corrected)
current_460K = [-1.54971402e-16, -1.54971402e-16, 1.26138451, 3.0674989,
                5.40770918, 8.19664794, 11.3365128, 14.7464149,
                18.3666023, 22.1544166, 26.0794515, 30.1197792,
                34.2593201, 38.4860659, 42.7908806, 47.1666857,
                51.6078954, 56.1100228, 60.6693979, 65.2829658, 69.9481386]

# Plotting
plt.figure(figsize=(10, 6))
plt.plot(voltage, current_260K, 'o-', label='260K')
plt.plot(voltage, current_300K, 's-', label='300K')
plt.plot(voltage, current_460K, '^-', label='460K')

# Labels and title
plt.xlabel('Voltage (V)', fontsize=12)
plt.ylabel('Current Density (A/cm²)', fontsize=12)
plt.title('I-V Characteristics at Different Temperatures', fontsize=14)
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage values (same for all temperatures)
voltage = [0, 0, 0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
           0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
           0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
           0.842105263, 0.894736842, 0.947368421, 1]

# Current at 260K
current_260K = [8.67191405e-14, 8.67191405e-14, 3.38059378e-06, 1.40949685e-05,
                5.04702463e-05, 0.000175844954, 0.000612655124, 0.00215743276,
                0.00774925487, 0.0287733314, 0.112703395, 0.472781785,
                1.99266622, 6.65733649, 15.2736091, 26.6886371, 39.8475849,
                54.1948029, 69.4467818, 85.4471044, 102.100342]

# Current at 300K (corrected)
current_300K = [-8.28396217e-14, -8.28396217e-14, 0.000148116285, 0.000554052138,
                0.00175082122, 0.00537015093, 0.0165756447, 0.0524358052,
                0.172358453, 0.587566883, 1.94612565, 5.36388414,
                11.269495, 19.078815, 28.1436994, 38.0659191, 48.6226599,
                59.6855136, 71.1759666, 83.0427182, 95.2499017]

# Current at 460K (corrected)
current_460K = [-1.54971402e-16, -1.54971402e-16, 1.26138451, 3.0674989,
                5.40770918, 8.19664794, 11.3365128, 14.7464149,
                18.3666023, 22.1544166, 26.0794515, 30.1197792,
                34.2593201, 38.4860659, 42.7908806, 47.1666857,
                51.6078954, 56.110

import matplotlib.pyplot as plt

# Voltage values (same for all temperatures)
voltage = [0, 0, 0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
           0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
           0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
           0.842105263, 0.894736842, 0.947368421, 1]

# Current at 260K
current_260K = [8.67191405e-14, 8.67191405e-14, 3.38059378e-06, 1.40949685e-05,
                5.04702463e-05, 0.000175844954, 0.000612655124, 0.00215743276,
                0.00774925487, 0.0287733314, 0.112703395, 0.472781785,
                1.99266622, 6.65733649, 15.2736091, 26.6886371, 39.8475849,
                54.1948029, 69.4467818, 85.4471044, 102.100342]

# Current at 300K (corrected)
current_300K = [-8.28396217e-14, -8.28396217e-14, 0.000148116285, 0.000554052138,
                0.00175082122, 0.00537015093, 0.0165756447, 0.0524358052,
                0.172358453, 0.587566883, 1.94612565, 5.36388414,
                11.269495, 19.078815, 28.1436994, 38.0659191, 48.6226599,
                59.6855136, 71.1759666, 83.0427182, 95.2499017]

# Current at 460K (corrected)
current_460K = [-1.54971402e-16, -1.54971402e-16, 1.26138451, 3.0674989,
                5.40770918, 8.19664794, 11.3365128, 14.7464149,
                18.3666023, 22.1544166, 26.0794515, 30.1197792,
                34.2593201, 38.4860659, 42.7908806, 47.1666857,
                51.6078954, 56.1100228, 60.6693979, 65.2829658, 69.9481386]

# Plotting
plt.figure(figsize=(10, 6))
plt.plot(voltage, current_260K, 'o-', label='260K')
plt.plot(voltage, current_300K, 's-', label='300K')
plt.plot(voltage, current_460K, '^-', label='460K')

# Labels only
plt.xlabel('Voltage (V)', fontsize=12)
plt.ylabel('Current Density (A/cm²)', fontsize=12)

plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage values (same for all cases)
voltage = [0, 0, 0.0315789474, 0.0631578947, 0.0947368421, 0.126315789, 0.157894737,
           0.189473684, 0.221052632, 0.252631579, 0.284210526, 0.315789474,
           0.347368421, 0.378947368, 0.410526316, 0.442105263, 0.473684211,
           0.505263158, 0.536842105, 0.568421053, 0.6]

# Current for Case 1: P=3µm, N=6µm
current_case1 = [-8.28396217e-14, -8.28396217e-14, 7.21386569e-05, 0.000199170972, 0.000435258119,
                 0.00088482486, 0.00175082122, 0.00343184513, 0.00671998434, 0.0132111153,
                 0.0261743434, 0.0524358052, 0.106527935, 0.219789695, 0.459174175,
                 0.958954004, 1.94612565, 3.69089311, 6.35643936, 9.91156311, 14.2066]

# Current for Case 2: P=6µm, N=6µm
current_case2 = [-3.3135849e-14, -3.3135849e-14, 7.21531903e-05, 0.000199211812, 0.000435350156,
                 0.000885014603, 0.00175117729, 0.00343238956, 0.0067202673, 0.0132081692,
                 0.026153523, 0.0523303651, 0.106039258, 0.217583339, 0.449395069,
                 0.91793217, 1.7954497, 3.24436018, 5.31758784, 7.94797586, 11.0203568]

# Current for Case 3: P=15µm, N=20µm
current_case3 = [-1.32543397e-14, -1.32543397e-14, 7.22565685e-05, 0.000199502606, 0.000436007476,
                 0.000886380019, 0.00175378869, 0.00343662135, 0.0067238497, 0.0131939739,
                 0.0260349159, 0.0517145946, 0.103222413, 0.205462654, 0.400712851,
                 0.744540305, 1.28189141, 2.02098762, 2.93613389, 3.98976726, 5.14788001]

# Plotting all three cases
plt.figure(figsize=(10, 6))
plt.plot(voltage, current_case1, 'o-', label='P=3µm, N=6µm')
plt.plot(voltage, current_case2, 's-', label='P=6µm, N=6µm')
plt.plot(voltage, current_case3, '^-', label='P=15µm, N=20µm')

plt.xlabel('Voltage (V)', fontsize=12)
plt.ylabel('Current Density (A/cm²)', fontsize=12)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage values (same for all three cases)
voltage = [0, 0, 0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
           0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
           0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
           0.842105263, 0.894736842, 0.947368421, 1.0]

# Case 1: P=3µm, N=6µm
current_case1 = [-8.28396217e-14, -8.28396217e-14, 0.000148116285, 0.000554052138,
                 0.00175082122, 0.00537015093, 0.0165756447, 0.0524358052,
                 0.172358453, 0.587566883, 1.94612565, 5.36388414, 11.269495,
                 19.078815, 28.1436994, 38.0659191, 48.6226599, 59.6855136,
                 71.1759666, 83.0427182, 95.2499017]

# Case 2: P=6µm, N=6µm
current_case2 = [-3.3135849e-14, -3.3135849e-14, 0.000148146398, 0.000554170281,
                 0.00175117729, 0.00537064788, 0.0165695437, 0.0523303651,
                 0.171021451, 0.571648763, 1.7954497, 4.55951764, 8.92872716,
                 14.4280847, 20.6424991, 27.325823, 34.3387993, 41.5998217,
                 49.0587416, 56.6833981, 64.4524282]

# Case 3: P=15µm, N=20µm
current_case3 = [-1.32543397e-14, -1.32543397e-14, 0.000148360714, 0.000555015584,
                 0.00175378869, 0.00537514571, 0.0165371623, 0.0517145946,
                 0.163523129, 0.496052546, 1.28189141, 2.6138253, 4.36565028,
                 6.38439314, 8.57067102, 10.866948, 13.239304, 15.6667516,
                 18.1356426, 20.6366998, 23.1633743]

# Plotting
plt.figure(figsize=(10, 6))
plt.plot(voltage, current_case1, 'o-', label='P=3µm, N=6µm')
plt.plot(voltage, current_case2, 's-', label='P=6µm, N=6µm')
plt.plot(voltage, current_case3, '^-', label='P=15µm, N=20µm')

plt.xlabel('Voltage (V)', fontsize=12)
plt.ylabel('Current Density (A/cm²)', fontsize=12)
plt.title('I-V Characteristics for Different p-n Junction Lengths', fontsize=14)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage values (same for all three cases)
voltage = [0, 0, 0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
           0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
           0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
           0.842105263, 0.894736842, 0.947368421, 1.0]

# Case 1: P=3µm, N=6µm
current_case1 = [-8.28396217e-14, -8.28396217e-14, 0.000148116285, 0.000554052138,
                 0.00175082122, 0.00537015093, 0.0165756447, 0.0524358052,
                 0.172358453, 0.587566883, 1.94612565, 5.36388414, 11.269495,
                 19.078815, 28.1436994, 38.0659191, 48.6226599, 59.6855136,
                 71.1759666, 83.0427182, 95.2499017]

# Case 2: P=6µm, N=6µm
current_case2 = [-3.3135849e-14, -3.3135849e-14, 0.000148146398, 0.000554170281,
                 0.00175117729, 0.00537064788, 0.0165695437, 0.0523303651,
                 0.171021451, 0.571648763, 1.7954497, 4.55951764, 8.92872716,
                 14.4280847, 20.6424991, 27.325823, 34.3387993, 41.5998217,
                 49.0587416, 56.6833981, 64.4524282]

# Case 3: P=15µm, N=20µm
current_case3 = [-1.32543397e-14, -1.32543397e-14, 0.000148360714, 0.000555015584,
                 0.00175378869, 0.00537514571, 0.0165371623, 0.0517145946,
                 0.163523129, 0.496052546, 1.28189141, 2.6138253, 4.36565028,
                 6.38439314, 8.57067102, 10.866948, 13.239304, 15.6667516,
                 18.1356426, 20.6366998, 23.1633743]

# Plotting
plt.figure(figsize=(10, 6))
plt.plot(voltage, current_case1, 'o-', label='P=3µm, N=6µm')
plt.plot(voltage, current_case2, 's-', label='P=6µm, N=6µm')
plt.plot(voltage, current_case3, '^-', label='P=15µm, N=20µm')

plt.xlabel('Voltage (V)', fontsize=12)
plt.ylabel('Current Density (A/cm²)', fontsize=12)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

!pip install pymatgen

from google.colab import files

uploaded = files.upload()  # Choose your CIF file when prompted

from pymatgen.core import Structure
import numpy as np

# Use your specific filename
filename = "CsPbI3(1).cifabs.cif"
structure = Structure.from_file(filename)

# Create a copy and apply small random displacements
max_disp = 0.01  # Angstrom
displaced_structure = structure.copy()

for i, site in enumerate(displaced_structure):
    disp = np.random.uniform(-max_disp, max_disp, size=3)
    displaced_structure.translate_sites([i], disp, frac_coords=False)

# Save the new structure
output_filename = "CsPbI3_distorted.cif"
displaced_structure.to(filename=output_filename)
print(f"Distorted CIF saved as: {output_filename}")

import matplotlib.pyplot as plt

# Voltage values (same for all temperatures)
voltage = [0, 0, 0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
           0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
           0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
           0.842105263, 0.894736842, 0.947368421, 1]

# Current at 260K
current_260K = [8.67191405e-14, 8.67191405e-14, 3.38059378e-06, 1.40949685e-05,
                5.04702463e-05, 0.000175844954, 0.000612655124, 0.00215743276,
                0.00774925487, 0.0287733314, 0.112703395, 0.472781785,
                1.99266622, 6.65733649, 15.2736091, 26.6886371, 39.8475849,
                54.1948029, 69.4467818, 85.4471044, 102.100342]

# Current at 300K
current_300K = [-8.28396217e-14, -8.28396217e-14, 0.000148116285, 0.000554052138,
                0.00175082122, 0.00537015093, 0.0165756447, 0.0524358052,
                0.172358453, 0.587566883, 1.94612565, 5.36388414,
                11.269495, 19.078815, 28.1436994, 38.0659191, 48.6226599,
                59.6855136, 71.1759666, 83.0427182, 95.2499017]

# Current at 460K
current_460K = [-1.54971402e-16, -1.54971402e-16, 1.26138451, 3.0674989,
                5.40770918, 8.19664794, 11.3365128, 14.7464149,
                18.3666023, 22.1544166, 26.0794515, 30.1197792,
                34.2593201, 38.4860659, 42.7908806, 47.1666857,
                51.6078954, 56.1100228, 60.6693979, 65.2829658, 69.9481386]

# Plotting
plt.figure(figsize=(10, 6))
plt.plot(voltage, current_260K, 'o-', label='260K')
plt.plot(voltage, current_300K, 's-', label='300K')
plt.plot(voltage, current_460K, '^-', label='460K')

# Labels
plt.xlabel('Voltage (V)', fontsize=12)
plt.ylabel('Current Density (A/cm²)', fontsize=12)

# Limit axes to start at zero
plt.xlim(left=0)
plt.ylim(bottom=0)

plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage values (same for all temperatures)
voltage = [0, 0, 0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
           0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
           0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
           0.842105263, 0.894736842, 0.947368421, 1]

# Current at 260K
current_260K = [8.67191405e-14, 8.67191405e-14, 3.38059378e-06, 1.40949685e-05,
                5.04702463e-05, 0.000175844954, 0.000612655124, 0.00215743276,
                0.00774925487, 0.0287733314, 0.112703395, 0.472781785,
                1.99266622, 6.65733649, 15.2736091, 26.6886371, 39.8475849,
                54.1948029, 69.4467818, 85.4471044, 102.100342]

# Current at 300K
current_300K = [-8.28396217e-14, -8.28396217e-14, 0.000148116285, 0.000554052138,
                0.00175082122, 0.00537015093, 0.0165756447, 0.0524358052,
                0.172358453, 0.587566883, 1.94612565, 5.36388414,
                11.269495, 19.078815, 28.1436994, 38.0659191, 48.6226599,
                59.6855136, 71.1759666, 83.0427182, 95.2499017]

# Current at 460K
current_460K = [-1.54971402e-16, -1.54971402e-16, 1.26138451, 3.0674989,
                5.40770918, 8.19664794, 11.3365128, 14.7464149,
                18.3666023, 22.1544166, 26.0794515, 30.1197792,
                34.2593201, 38.4860659, 42.7908806, 47.1666857,
                51.6078954, 56.1100228, 60.6693979, 65.2829658, 69.9481386]

# Plotting
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(voltage, current_260K, 'o-', label='260K')
ax.plot(voltage, current_300K, 's-', label='300K')
ax.plot(voltage, current_460K, '^-', label='460K')

# Set axis labels
ax.set_xlabel('Voltage (V)', fontsize=12)
ax.set_ylabel('Current Density (A/cm²)', fontsize=12)

# Set axis limits to start at 0
ax.set_xlim(left=0)
ax.set_ylim(bottom=0)

# Title below the graph
plt.subplots_adjust(bottom=0.2)  # make space for title
fig.text(0.5, 0.02, 'I-V Characteristics at Different Temperatures', ha='center', fontsize=14)

# Grid and legend
ax.grid(True)
ax.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage values
voltage = np.array([0, 0, 0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
                    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
                    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
                    0.842105263, 0.894736842, 0.947368421, 1])

# Current data
current_260K = np.array([8.67191405e-14, 8.67191405e-14, 3.38059378e-06, 1.40949685e-05,
                         5.04702463e-05, 0.000175844954, 0.000612655124, 0.00215743276,
                         0.00774925487, 0.0287733314, 0.112703395, 0.472781785,
                         1.99266622, 6.65733649, 15.2736091, 26.6886371, 39.8475849,
                         54.1948029, 69.4467818, 85.4471044, 102.100342])

current_300K = np.array([-8.28396217e-14, -8.28396217e-14, 0.000148116285, 0.000554052138,
                         0.00175082122, 0.00537015093, 0.0165756447, 0.0524358052,
                         0.172358453, 0.587566883, 1.94612565, 5.36388414,
                         11.269495, 19.078815, 28.1436994, 38.0659191, 48.6226599,
                         59.6855136, 71.1759666, 83.0427182, 95.2499017])

current_460K = np.array([-1.54971402e-16, -1.54971402e-16, 1.26138451, 3.0674989,
                         5.40770918, 8.19664794, 11.3365128, 14.7464149,
                         18.3666023, 22.1544166, 26.0794515, 30.1197792,
                         34.2593201, 38.4860659, 42.7908806, 47.1666857,
                         51.6078954, 56.1100228, 60.6693979, 65.2829658, 69.9481386])

# Estimate threshold voltage using where slope sharply increases
def estimate_threshold(voltage, current):
    dI_dV = np.gradient(current, voltage)
    threshold_index = np.argmax(dI_dV > np.max(dI_dV) * 0.1)  # 10% of max slope
    return voltage[threshold_index]

# Compute thresholds
th_260 = estimate_threshold(voltage, current_260K)
th_300 = estimate_threshold(voltage, current_300K)
th_460 = estimate_threshold(voltage, current_460K)

# Plot
plt.figure(figsize=(10, 6))
plt.plot(voltage, current_260K, 'o-', label='260K')
plt.plot(voltage, current_300K, 's-', label='300K')
plt.plot(voltage, current_460K, '^-', label='460K')

# Threshold lines and labels
for th, color, temp in zip([th_260, th_300, th_460],
                           ['blue', 'green', 'red'],
                           ['260K', '300K', '460K']):
    plt.axvline(x=th, color=color, linestyle='--', linewidth=1)
    plt.text(th + 0.005, 5, f'{temp} ~ {th:.2f}V', rotation=90, color=color, fontsize=10)

# Labels
plt.xlabel('Voltage (V)', fontsize=12)
plt.ylabel('Current Density (A/cm²)', fontsize=12)
plt.title('I-V Characteristics with Threshold Voltages', fontsize=14)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

pip install ase

from ase.io import read
import matplotlib.pyplot as plt

# Read Quantum ESPRESSO input file
atoms = read("pwscf.in", format="espresso-in")

# Save as CIF (for VESTA or other viewers)
atoms.write("WS2_monolayer.cif")

# Visualize the structure
atoms.plot()
plt.show()

from ase.io import read, write
from ase.visualize import view

# Read Quantum ESPRESSO input file
atoms = read("pwscf.in", format="espresso-in")

# View the structure interactively
view(atoms)

# Save as CIF (for VESTA or other software)
write("WS2_monolayer.cif", atoms)

pip install pymatgen

from pymatgen.core.structure import Structure
from pymatgen.io.cif import CifWriter

# Load CIF file
structure = Structure.from_file("WS2(5).cif")  # Rename your file if needed

# Convert to monolayer by removing periodicity in c-direction
structure.lattice = structure.lattice.with_lengths_and_angles(
    [structure.lattice.a, structure.lattice.b, 20.0],  # Adding 20 Å vacuum
    [90, 90, 120]  # Ensure correct lattice angles
)

# Save monolayer CIF
CifWriter(structure).write_file("WS2_monolayer.cif")

from pymatgen.core.structure import Structure
from pymatgen.io.cif import CifWriter

# Load CIF file (Update file name if needed)
cif_file = "WS2(5).cif"  # Change this if necessary
structure = Structure.from_file(cif_file)

# Modify lattice: Keep a and b same, add vacuum along c-axis
vacuum_thickness = 20.0  # 20 Å vacuum to isolate the monolayer
new_lattice = structure.lattice.with_lengths_and_angles(
    [structure.lattice.a, structure.lattice.b, vacuum_thickness],
    [90, 90, 120]  # Keeping hexagonal angles
)

# Update the structure with the new lattice
monolayer_structure = Structure(new_lattice, structure.species, structure.frac_coords)

# Save new CIF file
output_cif = "WS2_monolayer.cif"
CifWriter(monolayer_structure).write_file(output_cif)

print(f"Monolayer WS2 CIF file saved as {output_cif}")

# Required Libraries
from pymatgen.core import Structure
from pymatgen.io.cif import CifWriter

# Load the CIF file (ensure it's correctly named and uploaded)
cif_file = "/mnt/data/WS2 (5).cif"  # Update filename if needed
structure = Structure.from_file(cif_file)

# Convert to monolayer by increasing vacuum in c-direction
vacuum_thickness = 20  # Angstroms
structure.make_supercell([1, 1, 1])  # No replication, just for clarity
lattice = structure.lattice.matrix
lattice[2][2] += vacuum_thickness  # Increase c-lattice vector
structure.lattice = lattice

# Save the new monolayer structure
monolayer_cif = "/mnt/data/WS2_monolayer.cif"
CifWriter(structure).write_file(monolayer_cif)

# Output the file path
print(f"Monolayer WS2 CIF saved at: {monolayer_cif}")

import os
print(os.listdir("/mnt/data/"))

# Create figure object
plt.figure()
# Plot dotted line at Fermi energy
plt.axhline(0, c='gray', ls=':')
# Plot dotted lines at high-symmetry points
plt.axvline(K, c='gray')
plt.axvline(M, c='gray')

# Plot band structure
for band in range(len(bands)):
    plt.scatter(k, bands[band, :] - efermi, c='b', s = 5)

# Add the x and y-axis labels
plt.xlabel('')
plt.ylabel('Energy (eV)')
# Set the axis limits
# plt.xlim(gG1, gG2)
plt.ylim(-20, 20)
# Add labels for high-symmetry points
plt.xticks([gG1, K, M, gG2], ['$\Gamma$', 'K', 'M', '$\Gamma$'])
# Hide x-axis minor ticks
plt.tick_params(axis='x', which='minor', bottom=False, top=False)
# Save the figure
plt.savefig('plot-bands.pdf')
# Show the figure
plt.show()

import os
print(os.listdir())  # Lists all files in the current directory

import numpy as np
import matplotlib.pyplot as plt

# Load band structure data from file
data = np.loadtxt('gnubands.dat.gnu')

# Extract k-points and energies
k = data[:, 0]  # k-points
bands = data[:, 1:].T  # Transpose to get bands separately

efermi = 0  # Set Fermi level to 0 for visualization, update if needed

# Define high-symmetry points (modify according to actual data)
gG1, K, M, gG2 = k[0], k[len(k)//3], k[2*len(k)//3], k[-1]

# Create figure
plt.figure()

# Plot Fermi energy line
plt.axhline(0, c='gray', ls=':')

# Plot vertical lines at high-symmetry points
plt.axvline(K, c='gray')
plt.axvline(M, c='gray')

# Plot band structure
for band in bands:
    plt.plot(k, band - efermi, c='b', lw=1)

# Add labels and formatting
plt.xlabel('')
plt.ylabel('Energy (eV)')
plt.ylim(-5, 5)  # Adjust based on your system
plt.xticks([gG1, K, M, gG2], ['$\Gamma$', 'K', 'M', '$\Gamma$'])
plt.tick_params(axis='x', which='minor', bottom=False, top=False)

# Save and show plot
plt.savefig('plot-bands.pdf')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Read data from gnubands.dat.gnu
data = np.loadtxt("gnubands.dat.gnu")

# Extract k-points and energy values
k = data[:, 0]  # k-points
bands = data[:, 1:].T  # Energy bands (transpose to separate bands)

# Set Fermi energy
efermi = 8.8945

# Define high-symmetry points (adjust if needed)
gG1, K, M, gG2 = k[0], k[len(k)//3], k[2*len(k)//3], k[-1]

# Create figure object
plt.figure(figsize=(6, 5))

# Plot Fermi level as a dotted line
plt.axhline(0, color='gray', linestyle=':')

# Plot vertical lines at high-symmetry points
plt.axvline(K, color='gray', linestyle='--')
plt.axvline(M, color='gray', linestyle='--')

# Plot band structure
for band in bands:
    plt.plot(k, band - efermi, color='b', linewidth=1)

# Add labels
plt.xlabel('k-points')
plt.ylabel('Energy (eV)')
plt.xticks([gG1, K, M, gG2], [r'$\Gamma$', 'K', 'M', r'$\Gamma$'])
plt.ylim(-5, 5)  # Adjust y-axis range

# Save and show plot
plt.savefig("band_structure.pdf", dpi=300)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Load band structure data from file
data = np.loadtxt('gnubands.dat.gnu')

# Extract k-points and energies
k = data[:, 0]  # k-points
bands = data[:, 1:].T  # Transpose to get bands separately

efermi = 8.8945  # Set Fermi level to 0 for visualization, update if needed

# Define high-symmetry points (modify according to actual data)
gG1, K, M, gG2 = k[0], k[len(k)//3], k[2*len(k)//3], k[-1]

# Create figure
plt.figure()

# Plot Fermi energy line
plt.axhline(0, c='gray', ls=':')

# Plot vertical lines at high-symmetry points
plt.axvline(K, c='gray')
plt.axvline(M, c='gray')

# Plot band structure as scatter plot
for band in bands:
    plt.scatter(k, band - efermi, c='b', s=1)  # s controls point size

# Add labels and formatting
plt.xlabel('')
plt.ylabel('Energy (eV)')
plt.ylim(-4, 2.5)  # Adjust based on your system
plt.xticks([gG1, K, M, gG2], ['$\Gamma$', 'K', 'M', '$\Gamma$'])
plt.tick_params(axis='x', which='minor', bottom=False, top=False)

# Save and show plot
plt.savefig('plot-bands.pdf')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Load band structure data from file
data = np.loadtxt('bands.gnu.dat.gnu')

# Extract k-points and energies
k = data[:, 0]  # k-points
bands = data[:, 1:].T  # Transpose to get bands separately

efermi = 13.5983  # Set Fermi level to 0 for visualization, update if needed

# Define high-symmetry points (modify according to actual data)
gG1, K, M, gG2 = k[0], k[len(k)//3], k[2*len(k)//3], k[-1]

# Create figure
plt.figure()

# Plot Fermi energy line
plt.axhline(0, c='gray', ls=':')

# Plot vertical lines at high-symmetry points
plt.axvline(K, c='gray')
plt.axvline(M, c='gray')

# Plot band structure as scatter plot
for band in bands:
    plt.scatter(k, band - efermi, c='b', s=1)  # s controls point size

# Add labels and formatting
plt.xlabel('')
plt.ylabel('Energy (eV)')
plt.ylim(-2.5, 6)  # Adjust based on your system
plt.xticks([gG1, K, M, gG2], ['$\Gamma$', 'K', 'M', '$\Gamma$'])
plt.tick_params(axis='x', which='minor', bottom=False, top=False)

# Save and show plot
plt.savefig('plot-bands.pdf')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Load band structure data
data = np.loadtxt('bands.gnu.dat.gnu')

# Extract k-points and energy bands
k = data[:, 0]
bands = data[:, 1:].T  # Now each row is a band

# Set Fermi level (eV)
efermi = 13.5983

# Find high-symmetry points (Gamma, K, M, Gamma)
num_kpoints = len(k)
gG1 = k[0]
K = k[num_kpoints // 3]
M = k[2 * num_kpoints // 3]
gG2 = k[-1]

# Create figure
fig, ax = plt.subplots(figsize=(6, 8))

# Plot Fermi level
ax.axhline(0.0, color='red', linestyle='--', linewidth=1)

# Plot vertical lines at high-symmetry points
for high_sym_point in [K, M, gG2]:
    ax.axvline(high_sym_point, color='gray', linestyle='-', linewidth=0.8)

# Plot bands
for band in bands:
    ax.plot(k, band - efermi, color='blue', linewidth=0.7)

# Axis labels and ticks
ax.set_ylabel('Energy (eV)', fontsize=14)
ax.set_xticks([gG1, K, M, gG2])
ax.set_xticklabels(['$\Gamma$', 'K', 'M', '$\Gamma$'], fontsize=12)
ax.set_xlim(k[0], k[-1])
ax.set_ylim(-4, 6)
ax.tick_params(axis='both', which='both', direction='in', top=True, right=True)

# Remove minor x ticks
ax.minorticks_off()

# Tight layout for clean margins
plt.tight_layout()

# Save figure
plt.savefig('refined_band_structure.pdf', dpi=300)
plt.show()

import matplotlib.pyplot as plt

# Voltage and Current data extracted from your table
voltage = [
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
]

current = [
    0, 0,
    0.10197205, 0.334480277, 0.873749832, 2.0163836, 4.0448613,
    7.00932097, 10.7505276, 15.0697035, 19.811775, 24.8710911,
    30.1776227, 35.6844464, 41.3593682, 47.1796879, 53.1289445,
    59.1948635, 65.3680338, 71.641039, 78.0078739
]

# Plotting
plt.figure(figsize=(8,5))
plt.plot(voltage, current, marker='o', linestyle='-')
plt.title('I-V Characteristics of pn Diode at 400K')
plt.xlabel('Voltage (V)')
plt.ylabel('Current (A/cm²)')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    0, 0,
    0.10197205, 0.334480277, 0.873749832, 2.0163836, 4.0448613,
    7.00932097, 10.7505276, 15.0697035, 19.811775, 24.8710911,
    30.1776227, 35.6844464, 41.3593682, 47.1796879, 53.1289445,
    59.1948635, 65.3680338, 71.641039, 78.0078739
])

# Create plot
fig, ax = plt.subplots(figsize=(10,6))

# Set gray background
fig.patch.set_facecolor('greengray')
ax.set_facecolor('greengray')

# Plot data
ax.plot(voltage, current, marker='o', color='navy', linewidth=2, markersize=7)

# Axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Remove grid
ax.grid(False)

# Minor ticks and clean look
ax.minorticks_off()
ax.tick_params(axis='both', which='major', labelsize=12)

# Remove top and right border lines
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Show plot
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    0, 0,
    0.10197205, 0.334480277, 0.873749832, 2.0163836, 4.0448613,
    7.00932097, 10.7505276, 15.0697035, 19.811775, 24.8710911,
    30.1776227, 35.6844464, 41.3593682, 47.1796879, 53.1289445,
    59.1948635, 65.3680338, 71.641039, 78.0078739
])

# Create plot
fig, ax = plt.subplots(figsize=(10,6))

# Set green-gray background
green_gray = '#b2beb5'  # subtle black-gray tone
fig.patch.set_facecolor(black_gray)
ax.set_facecolor(black_gray)

# Plot data
ax.plot(voltage, current, marker='o', color='darkblue', linewidth=2, markersize=7)

# Axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Remove grid and unnecessary borders
ax.grid(False)
ax.minorticks_off()
ax.tick_params(axis='both', which='major', labelsize=12)
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Tight layout for cleaner appearance
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    0, 0,
    0.10197205, 0.334480277, 0.873749832, 2.0163836, 4.0448613,
    7.00932097, 10.7505276, 15.0697035, 19.811775, 24.8710911,
    30.1776227, 35.6844464, 41.3593682, 47.1796879, 53.1289445,
    59.1948635, 65.3680338, 71.641039, 78.0078739
])

# Create figure and axes
fig, ax = plt.subplots(figsize=(10, 6))

# Set greenish-gray background
greenish_gray = '#a8bba3'  # a soft green-gray color
fig.patch.set_facecolor(greenish_gray)
ax.set_facecolor(greenish_gray)

# Plot the data
ax.plot(voltage, current, marker='o', color='darkblue', linewidth=2, markersize=7)

# Axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Ensure all borders are visible
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Remove grid and minor ticks
ax.grid(False)
ax.minorticks_off()
ax.tick_params(axis='both', which='major', labelsize=12)

# Layout for neatness
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    0, 0,
    0.10197205, 0.334480277, 0.873749832, 2.0163836, 4.0448613,
    7.00932097, 10.7505276, 15.0697035, 19.811775, 24.8710911,
    30.1776227, 35.6844464, 41.3593682, 47.1796879, 53.1289445,
    59.1948635, 65.3680338, 71.641039, 78.0078739
])

# Create figure and axes
fig, ax = plt.subplots(figsize=(10, 6))

# Set powder blue background
powder_blue = '#d6eaf8'
fig.patch.set_facecolor(powder_blue)
ax.set_facecolor(powder_blue)

# Plot the data
ax.plot(voltage, current, marker='o', color='darkblue', linewidth=2, markersize=7)

# Axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Make all borders visible and bold
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Remove grid and minor ticks
ax.grid(False)
ax.minorticks_off()
ax.tick_params(axis='both', which='major', labelsize=12)

# Apply tight layout
plt.tight_layout()

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    0, 0,
    0.10197205, 0.334480277, 0.873749832, 2.0163836, 4.0448613,
    7.00932097, 10.7505276, 15.0697035, 19.811775, 24.8710911,
    30.1776227, 35.6844464, 41.3593682, 47.1796879, 53.1289445,
    59.1948635, 65.3680338, 71.641039, 78.0078739
])

# Create figure and axes
fig, ax = plt.subplots(figsize=(10, 6))

# Set background color ONLY for the plot area (inside borders)
powder_blue = '#d6eaf8'
ax.set_facecolor(powder_blue)

# Plot the data
ax.plot(voltage, current, marker='o', color='darkblue', linewidth=2, markersize=7)

# Axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Ensure all borders are visible and clean
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Remove grid and extra ticks
ax.grid(False)
ax.minorticks_off()
ax.tick_params(axis='both', which='major', labelsize=12)

# Keep figure background white (outside the plot)
fig.patch.set_facecolor('white')

# Neat layout
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data at 300K
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    -1.24259433e-14, -1.24259433e-14,
    0.00014812447, 0.00055408568, 0.00175093666, 0.00537047924,
    0.0165759238, 0.0524273008, 0.17221897, 0.585770249,
    1.92777887, 5.25684082, 10.937499, 18.3936248,
    27.0114321, 36.4172762, 46.4035595, 56.8524299,
    67.6939289, 78.8844696, 90.3954692
])

# Create plot
fig, ax = plt.subplots(figsize=(10, 6))

# Background split: left half powder blue, right half light gray
ax.axvspan(0, 0.5, facecolor='#d6eaf8')   # Powder blue
ax.axvspan(0.5, 1.0, facecolor='#e0e0e0') # Light gray

# Plot the I-V curve
ax.plot(voltage, current, marker='o', color='darkred', linewidth=2.2, markersize=7)

# Labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Border styling
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Remove grid and make clean
ax.grid(False)
ax.minorticks_off()
ax.tick_params(axis='both', which='major', labelsize=12)

# Keep outer area white
fig.patch.set_facecolor('white')

# Tight layout
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data at 300K
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    -1.24259433e-14, -1.24259433e-14,
    0.00014812447, 0.00055408568, 0.00175093666, 0.00537047924,
    0.0165759238, 0.0524273008, 0.17221897, 0.585770249,
    1.92777887, 5.25684082, 10.937499, 18.3936248,
    27.0114321, 36.4172762, 46.4035595, 56.8524299,
    67.6939289, 78.8844696, 90.3954692
])

# Create plot
fig, ax = plt.subplots(figsize=(10, 6))

# Set background color to powder blue for the entire plot
fig.patch.set_facecolor('#d6eaf8')  # Powder blue background

# Plot the curve (smooth line, blue color, no dots)
ax.plot(voltage, current, color='blue', linewidth=2.5)

# Axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Border settings to add border around the plot
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Removing grid lines for a clean look
ax.grid(False)
ax.minorticks_off()
ax.tick_params(axis='both', which='major', labelsize=12)

# Show plot
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Data at 300K
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    -1.24259433e-14, -1.24259433e-14,
    0.00014812447, 0.00055408568, 0.00175093666, 0.00537047924,
    0.0165759238, 0.0524273008, 0.17221897, 0.585770249,
    1.92777887, 5.25684082, 10.937499, 18.3936248,
    27.0114321, 36.4172762, 46.4035595, 56.8524299,
    67.6939289, 78.8844696, 90.3954692
])

# Create plot
fig, ax = plt.subplots(figsize=(10, 6))

# Set full background color (both figure and axes)
fig.patch.set_facecolor('#d6eaf8')  # Powder blue figure background
ax.set_facecolor('#d6eaf8')         # Powder blue axes background

# Plot the blue curve
ax.plot(voltage, current, color='blue', linewidth=2.5)

# Axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Add border lines
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Clean formatting
ax.grid(False)
ax.tick_params(axis='both', which='major', labelsize=12)
ax.minorticks_off()

# Ensure the full area is filled and no padding cuts off the color
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data at 300K
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    -1.24259433e-14, -1.24259433e-14,
    0.00014812447, 0.00055408568, 0.00175093666, 0.00537047924,
    0.0165759238, 0.0524273008, 0.17221897, 0.585770249,
    1.92777887, 5.25684082, 10.937499, 18.3936248,
    27.0114321, 36.4172762, 46.4035595, 56.8524299,
    67.6939289, 78.8844696, 90.3954692
])

# Create the plot
fig, ax = plt.subplots(figsize=(10, 6))

# Set background color only inside plot area (not outside border)
ax.set_facecolor('#d6eaf8')  # Powder blue inside the plot

# Plot blue curve without markers or dotted lines
ax.plot(voltage, current, color='blue', linewidth=2.5)

# Set axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Border lines (frame)
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(2)
    spine.set_color('black')

# Clean up plot look
ax.grid(False)
ax.tick_params(axis='both', labelsize=12)
ax.minorticks_off()

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage and Current data at 400K
voltage = [
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
]

current = [
    1.04003713e-14, 1.04003713e-14,
    1.24306759, 3.00693656, 5.27577213, 7.965988, 10.9844442,
    14.2547441, 17.7205796, 21.3417566, 25.0896215, 28.943524,
    32.8883565, 36.91289, 41.008651, 45.1691537, 49.3893669,
    53.6653379, 57.9939222, 62.3725867, 66.7992637
]

# Plotting
fig, ax = plt.subplots(figsize=(8, 5))
fig.patch.set_facecolor('#B0E0E6')  # Powder blue background
ax.set_facecolor('#B0E0E6')         # Powder blue background inside plot

# Solid blue curve without markers
ax.plot(voltage, current, color='blue', linewidth=2)

# Axis labels
ax.set_xlabel("Voltage (V)", fontsize=12)
ax.set_ylabel("Current (A/cm²)", fontsize=12)

# Borders (spines) - all visible and styled
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Optional: grid off to keep background clean
ax.grid(False)

# Show the plot
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage and Current data at 400K
voltage = [
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
]

current = [
    1.04003713e-14, 1.04003713e-14,
    1.24306759, 3.00693656, 5.27577213, 7.965988, 10.9844442,
    14.2547441, 17.7205796, 21.3417566, 25.0896215, 28.943524,
    32.8883565, 36.91289, 41.008651, 45.1691537, 49.3893669,
    53.6653379, 57.9939222, 62.3725867, 66.7992637
]

# Plotting
fig, ax = plt.subplots(figsize=(8, 5))
ax.set_facecolor('#B0E0E6')  # Powder blue only inside the plot area

# Plot the solid blue curve
ax.plot(voltage, current, color='blue', linewidth=2)

# Set axis labels
ax.set_xlabel("Voltage (V)", fontsize=12)
ax.set_ylabel("Current (A/cm²)", fontsize=12)

# Make all four border lines (spines) visible and styled
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Remove grid lines for a clean background
ax.grid(False)

# Make sure the background outside the plot remains white
fig.patch.set_facecolor('white')

# Display the plot
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage (same for all)
voltage = [
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
]

# Currents for each temperature
current_300K = [
    0, 0,
    0.10197205, 0.334480277, 0.873749832, 2.0163836, 4.0448613,
    7.00932097, 10.7505276, 15.0697035, 19.811775, 24.8710911,
    30.1776227, 35.6844464, 41.3593682, 47.1796879, 53.1289445,
    59.1948635, 65.3680338, 71.641039, 78.0078739
]

current_400K = [
    1.04003713e-14, 1.04003713e-14,
    1.24306759, 3.00693656, 5.27577213, 7.965988, 10.9844442,
    14.2547441, 17.7205796, 21.3417566, 25.0896215, 28.943524,
    32.8883565, 36.91289, 41.008651, 45.1691537, 49.3893669,
    53.6653379, 57.9939222, 62.3725867, 66.7992637
]

current_460K = [
    -1.04075905e-14, -1.04075905e-14,
    2.605853, 5.40276707, 8.35851252, 11.4463673, 14.645115,
    17.938212, 21.3128213, 24.7589632, 28.2688379, 31.8363081,
    35.4565081, 39.1255503, 42.8403049, 46.5982312, 50.3972502,
    54.2356455, 58.1119866, 62.0250693, 65.9738683
]

# Plot
plt.figure(figsize=(10, 6))
plt.plot(voltage, current_300K, label="300K", color="blue")
plt.plot(voltage, current_400K, label="400K", color="green")
plt.plot(voltage, current_460K, label="460K", color="red")

# Formatting
plt.title("I-V Characteristics of p-n Diode at Various Temperatures", fontsize=14)
plt.xlabel("Voltage (V)", fontsize=12)
plt.ylabel("Current (A/cm²)", fontsize=12)
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Voltage and Current data
voltage = [
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
]

current = [
    -1.04075905e-14, -1.04075905e-14,
    2.605853, 5.40276707, 8.35851252, 11.4463673, 14.645115,
    17.938212, 21.3128213, 24.7589632, 28.2688379, 31.8363081,
    35.4565081, 39.1255503, 42.8403049, 46.5982312, 50.3972502,
    54.2356455, 58.1119866, 62.0250693, 65.9738683
]

# Plotting
fig, ax = plt.subplots(figsize=(8, 5))
ax.set_facecolor('#B0E0E6')  # Powder blue inside plot

# Plot solid blue line
ax.plot(voltage, current, color='blue', linewidth=2)

# Axis labels
ax.set_xlabel("Voltage (V)", fontsize=12)
ax.set_ylabel("Current (A/cm²)", fontsize=12)

# Styling borders (spines)
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# No grid for a clean look
ax.grid(False)

# Keep background outside plot area white
fig.patch.set_facecolor('white')

# Layout and show
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data at 300K
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    -1.24259433e-14, -1.24259433e-14,
    0.00014812447, 0.00055408568, 0.00175093666, 0.00537047924,
    0.0165759238, 0.0524273008, 0.17221897, 0.585770249,
    1.92777887, 5.25684082, 10.937499, 18.3936248,
    27.0114321, 36.4172762, 46.4035595, 56.8524299,
    67.6939289, 78.8844696, 90.3954692
])

# Create plot
fig, ax = plt.subplots(figsize=(10, 6))

# Background: half powder blue, half light gray
ax.axvspan(0, 0.5, facecolor='#d6eaf8')   # Powder blue
ax.axvspan(0.5, 1.0, facecolor='#e0e0e0') # Light gray

# Plot the curve (no markers, smooth solid line, blue)
ax.plot(voltage, current, color='blue', linewidth=2.5)

# Axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Add border on all sides
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Style settings
ax.grid(False)
ax.minorticks_off()
ax.tick_params(axis='both', which='major', labelsize=12)
fig.patch.set_facecolor('white')

# Show
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    0, 0,
    0.10197205, 0.334480277, 0.873749832, 2.0163836, 4.0448613,
    7.00932097, 10.7505276, 15.0697035, 19.811775, 24.8710911,
    30.1776227, 35.6844464, 41.3593682, 47.1796879, 53.1289445,
    59.1948635, 65.3680338, 71.641039, 78.0078739
])

# Create plot
fig, ax = plt.subplots(figsize=(10, 6))

# Add background spans (left half powder blue, right half light gray)
ax.axvspan(0, 0.5, facecolor='#d6eaf8')   # Powder blue left half
ax.axvspan(0.5, 1.0, facecolor='#e0e0e0') # Light gray right half

# Plot line
ax.plot(voltage, current, marker='o', color='darkblue', linewidth=2, markersize=7)

# Axis labels
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Add border to all sides
for spine in ax.spines.values():
    spine.set_visible(True)
    spine.set_linewidth(1.5)
    spine.set_color('black')

# Clean up
ax.grid(False)
ax.minorticks_off()
ax.tick_params(axis='both', which='major', labelsize=12)
fig.patch.set_facecolor('white')

# Show plot
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Voltage and Current data
voltage = np.array([
    0, 0,
    0.0526315789, 0.105263158, 0.157894737, 0.210526316, 0.263157895,
    0.315789474, 0.368421053, 0.421052632, 0.473684211, 0.526315789,
    0.578947368, 0.631578947, 0.684210526, 0.736842105, 0.789473684,
    0.842105263, 0.894736842, 0.947368421, 1
])

current = np.array([
    0, 0,
    0.10197205, 0.334480277, 0.873749832, 2.0163836, 4.0448613,
    7.00932097, 10.7505276, 15.0697035, 19.811775, 24.8710911,
    30.1776227, 35.6844464, 41.3593682, 47.1796879, 53.1289445,
    59.1948635, 65.3680338, 71.641039, 78.0078739
])

# Set style
plt.style.use('seaborn-v0_8-deep')

# Create plot
fig, ax = plt.subplots(figsize=(10,6))

ax.plot(voltage, current,
        color='darkblue',
        marker='o',
        markersize=8,
        linestyle='-',
        linewidth=2,
        label='I-V Curve at 400K')

# Titles and labels
ax.set_title('Beautiful I-V Characteristics of pn Diode at 400K', fontsize=18, fontweight='bold', pad=20)
ax.set_xlabel('Voltage (V)', fontsize=14)
ax.set_ylabel('Current (A/cm²)', fontsize=14)

# Grid
ax.grid(True, which='both', linestyle='--', linewidth=0.5)

# Minor ticks
ax.minorticks_on()

# Customize ticks
ax.tick_params(axis='both', which='major', labelsize=12)
ax.tick_params(axis='both', which='minor', size=4)

# Customize frame (spines)
for spine in ax.spines.values():
    spine.set_linewidth(1.5)

# Legend
ax.legend(fontsize=12)

# Tight layout
plt.tight_layout()

# Show plot
plt.show()