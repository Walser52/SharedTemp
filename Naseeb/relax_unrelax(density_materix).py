# -*- coding: utf-8 -*-
"""relax/unrelax(density_materix).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w9bf45rdC6qlCerYq_1GB9hQ7G8WXz1b
"""

import numpy as np

def apply_symmetry_operations(r):
    """
    Apply 16 symmetry operations to a fractional coordinate r.

    Parameters:
        r (array-like): The input fractional coordinate (x, y, z)

    Returns:
        sym_eq (np.ndarray): 16 transformed fractional coordinates (wrapped in [0,1])
        unique_coords (np.ndarray): Unique positions among the 16
    """

    sym_ops = [
        (np.array([[ 1, 0, 0], [ 0, 1, 0], [ 0, 0, 1]]), np.array([0.0, 0.0, 0.0])),
        (np.array([[-1, 0, 0], [ 0,-1, 0], [ 0, 0,-1]]), np.array([0.0, 0.0, 0.0])),
        (np.array([[-1, 0, 0], [ 0,-1, 0], [ 0, 0, 1]]), np.array([0.5, 0.0, 0.0])),
        (np.array([[ 1, 0, 0], [ 0, 1, 0], [ 0, 0,-1]]), np.array([0.5, 0.0, 0.0])),
        (np.array([[-1, 0, 0], [ 0, 1, 0], [ 0, 0,-1]]), np.array([0.0, 0.0, 0.5])),
        (np.array([[ 1, 0, 0], [ 0,-1, 0], [ 0, 0, 1]]), np.array([0.0, 0.0, 0.5])),
        (np.array([[ 1, 0, 0], [ 0,-1, 0], [ 0, 0,-1]]), np.array([0.5, 0.0, 0.5])),
        (np.array([[-1, 0, 0], [ 0, 1, 0], [ 0, 0, 1]]), np.array([0.5, 0.0, 0.5])),
        (np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), np.array([0.5, 0.5, 0.0])),
        (np.array([[-1, 0, 0], [ 0,-1, 0], [ 0, 0,-1]]), np.array([0.5, 0.5, 0.0])),
        (np.array([[-1, 0, 0], [ 0,-1, 0], [ 0, 0, 1]]), np.array([0.0, 0.5, 0.0])),
        (np.array([[ 1, 0, 0], [ 0, 1, 0], [ 0, 0,-1]]), np.array([0.0, 0.5, 0.0])),
        (np.array([[-1, 0, 0], [ 0, 1, 0], [ 0, 0,-1]]), np.array([0.5, 0.5, 0.5])),
        (np.array([[ 1, 0, 0], [ 0,-1, 0], [ 0, 0, 1]]), np.array([0.5, 0.5, 0.5])),
        (np.array([[ 1, 0, 0], [ 0,-1, 0], [ 0, 0,-1]]), np.array([0.0, 0.5, 0.5])),
        (np.array([[-1, 0, 0], [ 0, 1, 0], [ 0, 0, 1]]), np.array([0.0, 0.5, 0.5])),
    ]

    sym_eq = np.full((16, 3), np.nan)

    print("Transformed positions of Ge:")
    for i, (W, w) in enumerate(sym_ops):
        r_new = W @ r + w
        r_wrapped = r_new % 1
        sym_eq[i] = r_wrapped
        print(f"{i+1:2d}: {r_wrapped}")

    unique_coords = np.unique(sym_eq, axis=0)
    print("\nUnique symmetry positions:")
    for i, pos in enumerate(unique_coords):
        print(f"{i+1:2d}: {pos}")

    print(f"\nNumber of unique positions: {len(unique_coords)}")
    return sym_eq, unique_coords
# Define the fractional position of the atom (Ge)
r = np.array([0.3726,	0.75,	0.75])

# Call the function
sym_eq, unique_eq = apply_symmetry_operations(r)

import numpy as np

def apply_symmetry_operations_to_atoms(atom_coords):
    """
    Apply 16 symmetry operations to each fractional coordinate in a list of atoms.

    Parameters:
        atom_coords (list of tuples or arrays): [(element, x, y, z), ...]

    Returns:
        all_sym_coords (np.ndarray): All transformed fractional coordinates
        unique_coords (np.ndarray): Unique coordinates after applying symmetry
    """
    sym_ops = [
        (np.array([[ 1, 0, 0], [ 0, 1, 0], [ 0, 0, 1]]), np.array([0.0, 0.0, 0.0])),
        (np.array([[-1, 0, 0], [ 0,-1, 0], [ 0, 0,-1]]), np.array([0.0, 0.0, 0.0])),
        (np.array([[-1, 0, 0], [ 0,-1, 0], [ 0, 0, 1]]), np.array([0.5, 0.0, 0.0])),
        (np.array([[ 1, 0, 0], [ 0, 1, 0], [ 0, 0,-1]]), np.array([0.5, 0.0, 0.0])),
        (np.array([[-1, 0, 0], [ 0, 1, 0], [ 0, 0,-1]]), np.array([0.0, 0.0, 0.5])),
        (np.array([[ 1, 0, 0], [ 0,-1, 0], [ 0, 0, 1]]), np.array([0.0, 0.0, 0.5])),
        (np.array([[ 1, 0, 0], [ 0,-1, 0], [ 0, 0,-1]]), np.array([0.5, 0.0, 0.5])),
        (np.array([[-1, 0, 0], [ 0, 1, 0], [ 0, 0, 1]]), np.array([0.5, 0.0, 0.5])),
        (np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), np.array([0.5, 0.5, 0.0])),
        (np.array([[-1, 0, 0], [ 0,-1, 0], [ 0, 0,-1]]), np.array([0.5, 0.5, 0.0])),
        (np.array([[-1, 0, 0], [ 0,-1, 0], [ 0, 0, 1]]), np.array([0.0, 0.5, 0.0])),
        (np.array([[ 1, 0, 0], [ 0, 1, 0], [ 0, 0,-1]]), np.array([0.0, 0.5, 0.0])),
        (np.array([[-1, 0, 0], [ 0, 1, 0], [ 0, 0,-1]]), np.array([0.5, 0.5, 0.5])),
        (np.array([[ 1, 0, 0], [ 0,-1, 0], [ 0, 0, 1]]), np.array([0.5, 0.5, 0.5])),
        (np.array([[ 1, 0, 0], [ 0,-1, 0], [ 0, 0,-1]]), np.array([0.0, 0.5, 0.5])),
        (np.array([[-1, 0, 0], [ 0, 1, 0], [ 0, 0, 1]]), np.array([0.0, 0.5, 0.5])),
    ]

    all_sym_coords = []

    print("Applying symmetry to all atoms...")
    for idx, (el, x, y, z) in enumerate(atom_coords):
        r = np.array([x, y, z])
        print(f"\nAtom {idx + 1} ({el}): {r}")
        for i, (W, w) in enumerate(sym_ops):
            r_new = W @ r + w
            r_wrapped = r_new % 1
            all_sym_coords.append(r_wrapped)
            print(f"  SymOp {i + 1:2d}: {r_wrapped}")

    all_sym_coords = np.array(all_sym_coords)
    unique_coords = np.unique(all_sym_coords, axis=0)

    print(f"\nTotal symmetry-generated positions: {len(all_sym_coords)}")
    print(f"Unique positions after symmetry: {len(unique_coords)}")
    return all_sym_coords, unique_coords


# Atom list: (element, x, y, z)
fractional_coords = [
    ('Ge', 0.52256967, 0.58304605, 0.35667306),
    ('Ge', 0.29371137, 0.62881237, 0.22570666),
    ('S',  0.63454719, 0.53778926, 0.39311385),
    ('S',  0.35794475, 0.56162529, 0.31424425),
    ('S',  0.08640571, 0.62500405, 0.25502388),
    ('S',  0.32314085, 0.62967463, 0.03758758),
    ('S',  0.32377792, 0.69826685, 0.26882620),
    ('S',  0.00000000, 0.87945895, 0.50000000),
    ('S',  0.08802720, 0.71497518, 0.40821585),
    ('S',  0.88785211, 0.78355338, 0.42304940),
    ('S',  0.41020577, 0.53404427, 0.90532057),
    ('P',  0.50000000, 0.74942520, 0.50000000),
    ('P',  0.00000000, 0.00000000, 0.00000000),
    ('Li', 0.75531605, 0.56795059, 0.02278389),
    ('Li', 0.50000000, 0.84130133, 0.50000000),
    ('Li', 0.32860392, 0.80737948, 0.58305816),
    ('Li', 0.48103066, 0.81098296, 0.23166585),
    ('Li', 0.00000000, 0.00000000, 0.50000000),
    ('Li', 0.37850221, 0.99795416, 0.74730216),
    ('Li', 0.50000000, 0.58512610, 0.00000000),
    ('Li', 0.75000000, 0.75000000, 0.31615366),
    ('Li', 0.75000000, 0.75000000, 0.62260398),
    ('Li', 0.66187305, 0.66120208, 0.55351684),
]

# Run the function
all_transformed, unique_positions = apply_symmetry_operations_to_atoms(fractional_coords)

from ase.io import read
import spglib
import pandas as pd
import numpy as np

def get_symmetry_dataset(atoms, symprec=1e-5):
    cell = (atoms.cell, atoms.get_scaled_positions(), atoms.get_atomic_numbers())
    return spglib.get_symmetry_dataset(cell, symprec)

def extract_symmetry_inequivalent_atoms(atoms, dataset):
    eq_atoms = dataset['equivalent_atoms']
    wyckoffs = dataset['wyckoffs']
    std_pos = dataset['std_positions']
    unique_indices = np.unique(eq_atoms)

    data = []
    for idx in unique_indices:
        elem = atoms[idx].symbol
        coords = std_pos[idx]
        wyck = wyckoffs[idx]
        mult = list(eq_atoms).count(idx)
        data.append((elem, coords, wyck, mult))
    return data

def compute_density_matrix(relaxed_data, unrelaxed_atoms):
    unrelaxed_frac = unrelaxed_atoms.get_scaled_positions()
    result = {}

    for i, (_, r_coords, _, _) in enumerate(relaxed_data):
        dists = np.linalg.norm(unrelaxed_frac - r_coords, axis=1)
        result[f'Atom_{i+1}'] = dists

    return pd.DataFrame(result)

def analyze_relaxation_iteration(relax_path, unrelaxed_path, iteration_index=0):
    all_steps = read(relax_path, index=':')
    if iteration_index >= len(all_steps):
        raise ValueError(f"Iteration {iteration_index} out of range. Max: {len(all_steps)-1}")

    relaxed_atoms = all_steps[iteration_index]
    unrelaxed_atoms = read(unrelaxed_path)

    dataset = get_symmetry_dataset(relaxed_atoms)
    relaxed_info = extract_symmetry_inequivalent_atoms(relaxed_atoms, dataset)

    print(f"\nSelected ionic iteration: {iteration_index}")
    print(f"Found {len(relaxed_info)} symmetry inequivalent atoms:")
    for i, (elem, coords, wyck, mult) in enumerate(relaxed_info):
        print(f"\nAtom {i+1}: {elem}")
        print(f"  Fractional coords : {np.round(coords, 6)}")
        print(f"  Wyckoff position  : {wyck}")
        print(f"  Multiplicity      : {mult}")

    df = compute_density_matrix(relaxed_info, unrelaxed_atoms)
    print("\nDensity (distance) matrix [in fractional coords]:")
    print(df.round(4))
    return df

# === Usage ===
relax_out_path = "/home/naseeb/Desktop/DFT Books/LGPS/L21/4th(3rd in derive)relaxation/vc-relax.out"
unrelaxed_cif_path = "/home/naseeb/Desktop/DFT Books/LGPS/L21/4th(3rd in derive)relaxation/LGPS_Ccca.cif"
iteration = 1  # <-- 0 = 1st step, 1 = 2nd step, -1 = final step

df_density = analyze_relaxation_iteration(relax_out_path, unrelaxed_cif_path, iteration_index=iteration)